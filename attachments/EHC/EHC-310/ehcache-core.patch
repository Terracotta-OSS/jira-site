Index: src/main/java/net/sf/ehcache/extension/CacheExtensionFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/extension/CacheExtensionFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/extension/CacheExtensionFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.extension;
 
-import net.sf.ehcache.Ehcache;
-
 import java.util.Properties;
 
+import net.sf.ehcache.Ehcache;
+
 /**
  * An abstract factory for creating <code>CacheExtension</code>s. Implementers should provide their own
  * concrete factory extending this factory. It can then be configured in ehcache.xml.
Index: src/main/java/net/sf/ehcache/Element.java
===================================================================
--- src/main/java/net/sf/ehcache/Element.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/Element.java	(working copy)
@@ -24,8 +24,9 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A Cache Element, consisting of a key, value and attributes.
@@ -45,7 +46,7 @@
      */
     private static final long serialVersionUID = 3343087714201120157L;
 
-    private static final Logger LOG = Logger.getLogger(Element.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(Element.class);
 
     private static final long ONE_SECOND = 1000L;
 
@@ -462,11 +463,9 @@
             ois = new ObjectInputStream(bin);
             newValue = (Serializable) ois.readObject();
         } catch (IOException e) {
-            LOG.log(Level.SEVERE, "Error cloning Element with key " + key
-                    + " during serialization and deserialization of value");
+            LOG.error("Error cloning Element with key {} during serialization and deserialization of value", key);
         } catch (ClassNotFoundException e) {
-            LOG.log(Level.SEVERE, "Error cloning Element with key " + key
-                    + " during serialization and deserialization of value");
+            LOG.error("Error cloning Element with key {} during serialization and deserialization of value", key);
         } finally {
             try {
                 if (oos != null) {
@@ -476,7 +475,7 @@
                     ois.close();
                 }
             } catch (Exception e) {
-                LOG.log(Level.SEVERE, "Error closing Stream");
+                LOG.error("Error closing Stream");
             }
         }
         return newValue;
@@ -507,14 +506,14 @@
             size = bout.size();
             return size;
         } catch (IOException e) {
-            LOG.log(Level.FINE, "Error measuring element size for element with key " + key + ". Cause was: " + e.getMessage());
+            LOG.debug("Error measuring element size for element with key {}. Cause was: {}", key, e.getMessage());
         } finally {
             try {
                 if (oos != null) {
                     oos.close();
                 }
             } catch (Exception e) {
-                LOG.log(Level.SEVERE, "Error closing ObjectOutputStream");
+                LOG.error("Error closing ObjectOutputStream");
             }
         }
 
Index: src/main/java/net/sf/ehcache/Cache.java
===================================================================
--- src/main/java/net/sf/ehcache/Cache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/Cache.java	(working copy)
@@ -16,21 +16,6 @@
 
 package net.sf.ehcache;
 
-import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
-import net.sf.ehcache.config.CacheConfiguration;
-import net.sf.ehcache.config.DiskStoreConfiguration;
-import net.sf.ehcache.event.CacheEventListener;
-import net.sf.ehcache.event.RegisteredEventListeners;
-import net.sf.ehcache.exceptionhandler.CacheExceptionHandler;
-import net.sf.ehcache.extension.CacheExtension;
-import net.sf.ehcache.loader.CacheLoader;
-import net.sf.ehcache.store.DiskStore;
-import net.sf.ehcache.store.LruMemoryStore;
-import net.sf.ehcache.store.MemoryStore;
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-import net.sf.ehcache.store.Policy;
-import net.sf.ehcache.store.Store;
-
 import java.io.IOException;
 import java.io.Serializable;
 import java.net.InetAddress;
@@ -51,8 +36,24 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
+import net.sf.ehcache.config.CacheConfiguration;
+import net.sf.ehcache.config.DiskStoreConfiguration;
+import net.sf.ehcache.event.CacheEventListener;
+import net.sf.ehcache.event.RegisteredEventListeners;
+import net.sf.ehcache.exceptionhandler.CacheExceptionHandler;
+import net.sf.ehcache.extension.CacheExtension;
+import net.sf.ehcache.loader.CacheLoader;
+import net.sf.ehcache.store.DiskStore;
+import net.sf.ehcache.store.LruMemoryStore;
+import net.sf.ehcache.store.MemoryStore;
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+import net.sf.ehcache.store.Policy;
+import net.sf.ehcache.store.Store;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Cache is the central class in ehcache. Caches have {@link Element}s and are managed
@@ -126,7 +127,7 @@
      */
     private static final int DEFAULT_SPOOL_BUFFER_SIZE = 30;
 
-    private static final Logger LOG = Logger.getLogger(Cache.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(Cache.class);
 
     private static final MemoryStoreEvictionPolicy DEFAULT_MEMORY_STORE_EVICTION_POLICY = MemoryStoreEvictionPolicy.LRU;
 
@@ -145,9 +146,9 @@
         try {
             localhost = InetAddress.getLocalHost();
         } catch (UnknownHostException e) {
-            LOG.log(Level.SEVERE, "Unable to set localhost. This prevents creation of a GUID. Cause was: " + e.getMessage(), e);
+            LOG.error("Unable to set localhost. This prevents creation of a GUID. Cause was: " + e.getMessage(), e);
         } catch (java.lang.NoClassDefFoundError e) {
-            LOG.log(Level.FINE, "InetAddress is being blocked by your runtime environment. e.g. Google App Engine." +
+            LOG.debug("InetAddress is being blocked by your runtime environment. e.g. Google App Engine." +
                     " Ehcache will work as a local cache.");
         }
     }
@@ -289,9 +290,9 @@
                  long diskExpiryThreadIntervalSeconds) {
         this(name, maxElementsInMemory, DEFAULT_MEMORY_STORE_EVICTION_POLICY, overflowToDisk, null,
                 eternal, timeToLiveSeconds, timeToIdleSeconds, diskPersistent, diskExpiryThreadIntervalSeconds, null, null);
-        LOG.log(Level.WARNING, "An API change between ehcache-1.1 and ehcache-1.2 results in the persistence path being set to " +
-                DiskStoreConfiguration.getDefaultPath() + " when the ehcache-1.1 constructor is used. " +
-                "Please change to the 1.2 constructor.");
+        LOG.warn("An API change between ehcache-1.1 and ehcache-1.2 results in the persistence path being set to {}" +
+                " when the ehcache-1.1 constructor is used. Please change to the 1.2 constructor.",
+                 DiskStoreConfiguration.getDefaultPath());
     }
 
 
@@ -631,11 +632,9 @@
             }
 
             if (configuration.getMaxElementsInMemory() == 0) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Cache: " + configuration.getName()
-                            + " has a maxElementsInMemory of 0. It is strongly recommended to " +
-                            "have a maximumSize of at least 1. Performance is halved by not using a MemoryStore.");
-                }
+                LOG.warn("Cache: {} has a maxElementsInMemory of 0. It is strongly recommended to " +
+                        "have a maximumSize of at least 1. Performance is halved by not using a MemoryStore.",
+                        configuration.getName());
             }
 
             this.diskStore = createDiskStore();
@@ -650,15 +649,12 @@
             initialiseRegisteredCacheLoaders();
         }
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Initialised cache: " + configuration.getName());
-        }
+        LOG.debug("Initialised cache: {}", configuration.getName());
 
         if (disabled) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "Cache: " + configuration.getName() + " is disabled because the " + NET_SF_EHCACHE_DISABLED
-                        + " property was set to true. No elements will be added to the cache.");
-            }
+            LOG.warn("Cache: {} is disabled because the property was set to true. No elements will " +
+                    "be added to the cache.",
+                    configuration.getName(), NET_SF_EHCACHE_DISABLED);
         }
     }
 
@@ -765,8 +761,8 @@
 
         if (element == null) {
             if (doNotNotifyCacheReplicators) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.fine("Element from replicated put is null. This happens because the element is a SoftReference" +
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Element from replicated put is null. This happens because the element is a SoftReference" +
                             " and it has been collected.Increase heap memory on the JVM or set -Xms to be the same as " +
                             "-Xmx to avoid this problem.");
                 }
@@ -906,9 +902,7 @@
         }
         if (element == null) {
             missCountNotFound.incrementAndGet();
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.fine(configuration.getName() + " cache - Miss");
-            }
+            LOG.debug("{} cache - Miss", configuration.getName());
         } else {
             hitCount.incrementAndGet();
         }
@@ -979,17 +973,13 @@
      */
     public void load(final Object key) throws CacheException {
         if (registeredCacheLoaders.size() == 0) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.fine("The CacheLoader is null. Returning.");
-            }
+            LOG.debug("The CacheLoader is null. Returning.");
             return;
         }
 
         boolean existsOnCall = isKeyInCache(key);
         if (existsOnCall) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "The key " + key + " exists in the cache. Returning.");
-            }
+            LOG.debug("The key {} exists in the cache. Returning.", key);
             return;
         }
 
@@ -1102,9 +1092,7 @@
     public void loadAll(final Collection keys, final Object argument) throws CacheException {
 
         if (registeredCacheLoaders.size() == 0) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "The CacheLoader is null. Returning.");
-            }
+            LOG.debug("The CacheLoader is null. Returning.");
             return;
         }
         if (keys == null) {
@@ -1263,9 +1251,7 @@
         }
         if (element != null) {
             if (isExpired(element)) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, configuration.getName() + " Memory cache hit, but element expired");
-                }
+                LOG.debug("{} Memory cache hit, but element expired", configuration.getName());
                 if (updateStatistics) {
                     missCountExpired.incrementAndGet();
                 }
@@ -1293,9 +1279,7 @@
         }
         if (element != null) {
             if (isExpired(element)) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, configuration.getName() + " cache - Disk Store hit, but element expired");
-                }
+                LOG.debug("{} cache - Disk Store hit, but element expired", configuration.getName());
                 missCountExpired.incrementAndGet();
                 remove(key, true, notifyListeners, false);
                 element = null;
@@ -2313,8 +2297,8 @@
                         }
                     }
                 } catch (Throwable e) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Problem during load. Load will not be completed. Cause was " + e.getCause(), e);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Problem during load. Load will not be completed. Cause was " + e.getCause(), e);
                     }
                     throw new CacheException("Problem during load. Load will not be completed. Cause was " + e.getCause(), e);
                 }
@@ -2370,8 +2354,8 @@
                         put(new Element(key, map.get(key)));
                     }
                 } catch (Throwable e) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Problem during load. Load will not be completed. Cause was " + e.getCause(), e);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Problem during load. Load will not be completed. Cause was " + e.getCause(), e);
                     }
                 }
             }
Index: src/main/java/net/sf/ehcache/event/CacheManagerEventListenerRegistry.java
===================================================================
--- src/main/java/net/sf/ehcache/event/CacheManagerEventListenerRegistry.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/event/CacheManagerEventListenerRegistry.java	(working copy)
@@ -16,12 +16,12 @@
 
 package net.sf.ehcache.event;
 
-import net.sf.ehcache.Status;
-
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
+import net.sf.ehcache.Status;
+
 /**
  * Registered listeners for registering and unregistering CacheManagerEventListeners and sending notifications to registrants.
  * <p/>
Index: src/main/java/net/sf/ehcache/event/RegisteredEventListeners.java
===================================================================
--- src/main/java/net/sf/ehcache/event/RegisteredEventListeners.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/event/RegisteredEventListeners.java	(working copy)
@@ -16,15 +16,15 @@
 
 package net.sf.ehcache.event;
 
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.distribution.CacheReplicator;
 
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
 /**
  * Registered listeners for registering and unregistering CacheEventListeners and multicasting notifications to registrants.
  * <p/>
Index: src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProviderFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProviderFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProviderFactory.java	(working copy)
@@ -16,16 +16,17 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.util.PropertyUtil;
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.Properties;
 import java.util.StringTokenizer;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.util.PropertyUtil;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Builds a factory based on RMI
@@ -35,7 +36,7 @@
  */
 public class RMICacheManagerPeerProviderFactory extends CacheManagerPeerProviderFactory {
 
-    private static final Logger LOG = Logger.getLogger(RMICacheManagerPeerProviderFactory.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICacheManagerPeerProviderFactory.class);
 
     private static final String HOST_NAME = "hostName";
     private static final String PEER_DISCOVERY = "peerDiscovery";
@@ -75,7 +76,7 @@
     protected CacheManagerPeerProvider createManuallyConfiguredCachePeerProvider(Properties properties) {
         String rmiUrls = PropertyUtil.extractAndLogProperty(RMI_URLS, properties);
         if (rmiUrls == null || rmiUrls.length() == 0) {
-            LOG.log(Level.INFO, "Starting manual peer provider with empty list of peers. " +
+            LOG.info("Starting manual peer provider with empty list of peers. " +
                     "No replication will occur unless peers are added.");
             rmiUrls = new String();
         }
@@ -86,9 +87,7 @@
             String rmiUrl = stringTokenizer.nextToken();
             rmiUrl = rmiUrl.trim();
             rmiPeerProvider.registerPeer(rmiUrl);
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Registering peer " + rmiUrl);
-            }
+            LOG.debug("Registering peer {}", rmiUrl);
         }
         return rmiPeerProvider;
     }
@@ -103,7 +102,7 @@
         if (hostName != null && hostName.length() != 0) {
             hostAddress = InetAddress.getByName(hostName);
             if (hostName.equals("localhost")) {
-                LOG.log(Level.WARNING, "Explicitly setting the multicast hostname to 'localhost' is not recommended. "
+                LOG.warn("Explicitly setting the multicast hostname to 'localhost' is not recommended. "
                         + "It will only work if all CacheManager peers are on the same machine.");
             }
         }
@@ -117,7 +116,7 @@
         Integer timeToLive;
         if (packetTimeToLiveString == null) {
             timeToLive = new Integer(1);
-            LOG.log(Level.FINE, "No TTL set. Setting it to the default of 1, which means packets are limited to the same subnet.");
+            LOG.debug("No TTL set. Setting it to the default of 1, which means packets are limited to the same subnet.");
         } else {
             timeToLive = new Integer(packetTimeToLiveString);
             if (timeToLive.intValue() < 0 || timeToLive.intValue() > MAXIMUM_TTL) {
Index: src/main/java/net/sf/ehcache/distribution/ManualRMICacheManagerPeerProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/ManualRMICacheManagerPeerProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/ManualRMICacheManagerPeerProvider.java	(working copy)
@@ -17,15 +17,16 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A provider of Peer RMI addresses based off manual configuration.
@@ -39,7 +40,7 @@
  */
 public final class ManualRMICacheManagerPeerProvider extends RMICacheManagerPeerProvider {
 
-    private static final Logger LOG = Logger.getLogger(ManualRMICacheManagerPeerProvider.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ManualRMICacheManagerPeerProvider.class);
 
     /**
      * Empty constructor.
@@ -94,16 +95,14 @@
                     cachePeer = lookupRemoteCachePeer(rmiUrl);
                     remoteCachePeers.add(cachePeer);
                 } catch (Exception e) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Looking up rmiUrl " + rmiUrl + " through exception " + e.getMessage()
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Looking up rmiUrl " + rmiUrl + " through exception " + e.getMessage()
                                 + ". This may be normal if a node has gone offline. Or it may indicate network connectivity"
                                 + " difficulties", e);
                     }
                 }
             } else {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "rmiUrl " + rmiUrl + " should never be stale for a manually configured cluster.");
-                }
+                LOG.debug("rmiUrl {} should never be stale for a manually configured cluster.", rmiUrl);
                 staleList.add(rmiUrl);
             }
 
Index: src/main/java/net/sf/ehcache/distribution/EventMessage.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/EventMessage.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/EventMessage.java	(working copy)
@@ -16,12 +16,12 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.Element;
-
 import java.io.IOException;
 import java.io.Serializable;
 import java.lang.ref.SoftReference;
 
+import net.sf.ehcache.Element;
+
 /**
  * An Event Message, in respect of a particular cache.
  * <p/>
Index: src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProvider.java	(working copy)
@@ -16,11 +16,11 @@
 
 package net.sf.ehcache.distribution;
 
+import java.util.List;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 
-import java.util.List;
-
 /**
  * Provides a discovery service to locate {@link CachePeer} RMI listener peers for a Cache.
  * @author Greg Luck
Index: src/main/java/net/sf/ehcache/distribution/RMICachePeer.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICachePeer.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICachePeer.java	(working copy)
@@ -16,9 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-
 import java.io.Serializable;
 import java.rmi.Remote;
 import java.rmi.RemoteException;
@@ -26,8 +23,12 @@
 import java.rmi.server.UnicastRemoteObject;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * An RMI based implementation of <code>CachePeer</code>.
@@ -39,7 +40,7 @@
  */
 public class RMICachePeer extends UnicastRemoteObject implements CachePeer, Remote {
 
-    private static final Logger LOG = Logger.getLogger(RMICachePeer.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICachePeer.class);
 
     private final String hostname;
     private final Integer rmiRegistryPort;
@@ -171,8 +172,8 @@
      */
     public void put(Element element) throws RemoteException, IllegalArgumentException, IllegalStateException {
         cache.put(element, true);
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "RMICachePeer for cache " + cache.getName() + ": remote put received. Element is: " + element);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("RMICachePeer for cache {}: remote put received. Element is: {}", cache.getName(), element);
         }
     }
 
@@ -186,9 +187,7 @@
      * @throws IllegalStateException
      */
     public final boolean remove(Serializable key) throws RemoteException, IllegalStateException {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "RMICachePeer for cache " + cache.getName() + ": remote remove received for key: " + key);
-        }
+        LOG.debug("RMICachePeer for cache {}: remote remove received for key: {}", cache.getName(), key);
         return cache.remove(key, true);
     }
 
@@ -198,9 +197,7 @@
      * @throws IllegalStateException if the cache is not {@link net.sf.ehcache.Status#STATUS_ALIVE}
      */
     public final void removeAll() throws RemoteException, IllegalStateException {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "RMICachePeer for cache " + cache.getName() + ": remote removeAll received");
-        }
+        LOG.debug("RMICachePeer for cache {}: remote removeAll received", cache.getName());
         cache.removeAll(true);
     }
 
@@ -219,7 +216,7 @@
             } else if (eventMessage.getEvent() == EventMessage.REMOVE_ALL) {
                 removeAll();
             } else {
-                LOG.log(Level.SEVERE, "Unknown event: " + eventMessage);
+                LOG.error("Unknown event: {}", eventMessage);
             }
         }
     }
Index: src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerFactory.java	(working copy)
@@ -16,13 +16,13 @@
 
 package net.sf.ehcache.distribution;
 
+import java.net.UnknownHostException;
+import java.util.Properties;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.net.UnknownHostException;
-import java.util.Properties;
-
 /**
  * Builds a listener based on RMI.
  * <p/>
Index: src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProviderFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProviderFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/CacheManagerPeerProviderFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheManager;
-
 import java.util.Properties;
 
+import net.sf.ehcache.CacheManager;
+
 /**
  * An abstract factory for creating peers. Implementers should provide their own
  * concrete factory extending this factory. It can then be configured in ehcache.xml
Index: src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatSender.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatSender.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatSender.java	(working copy)
@@ -16,8 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheManager;
-
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.InetAddress;
@@ -25,8 +23,11 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheManager;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Sends heartbeats to a multicast group containing a compressed list of URLs.
@@ -50,7 +51,7 @@
 public final class MulticastKeepaliveHeartbeatSender {
 
 
-    private static final Logger LOG = Logger.getLogger(MulticastKeepaliveHeartbeatSender.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(MulticastKeepaliveHeartbeatSender.class);
 
     private static final int DEFAULT_HEARTBEAT_INTERVAL = 5000;
     private static final int MINIMUM_HEARTBEAT_INTERVAL = 1000;
@@ -145,14 +146,14 @@
                             }
                         } catch (InterruptedException e) {
                             if (!stopped) {
-                                LOG.log(Level.SEVERE, "Error receiving heartbeat. Initial cause was " + e.getMessage(), e);
+                                LOG.error("Error receiving heartbeat. Initial cause was " + e.getMessage(), e);
                             }
                         }
                     }
                 } catch (IOException e) {
-                    LOG.log(Level.FINE, "Error on multicast socket", e);
+                    LOG.debug("Error on multicast socket", e);
                 } catch (Throwable e) {
-                    LOG.log(Level.INFO, "Unexpected throwable in run thread. Continuing..." + e.getMessage(), e);
+                    LOG.info("Unexpected throwable in run thread. Continuing..." + e.getMessage(), e);
                 } finally {
                     closeSocket();
                 }
@@ -160,7 +161,7 @@
                     try {
                         sleep(heartBeatInterval);
                     } catch (InterruptedException e) {
-                        LOG.log(Level.SEVERE, "Sleep after error interrupted. Initial cause was " + e.getMessage(), e);
+                        LOG.error("Sleep after error interrupted. Initial cause was " + e.getMessage(), e);
                     }
                 }
             }
@@ -189,7 +190,7 @@
                     byte[] uncompressedUrlList = PayloadUtil.assembleUrlList(localCachePeersSubList);
                     byte[] compressedUrlList = PayloadUtil.gzip(uncompressedUrlList);
                     if (compressedUrlList.length > PayloadUtil.MTU) {
-                        LOG.log(Level.SEVERE, "Heartbeat is not working. Configure fewer caches for replication. " +
+                        LOG.error("Heartbeat is not working. Configure fewer caches for replication. " +
                                 "Size is " + compressedUrlList.length + " but should be no greater than" +
                                 PayloadUtil.MTU);
                     }
@@ -244,16 +245,16 @@
                     try {
                         socket.leaveGroup(groupMulticastAddress);
                     } catch (IOException e) {
-                        LOG.log(Level.SEVERE, "Error leaving multicast group. Message was " + e.getMessage());
+                        LOG.error("Error leaving multicast group. Message was " + e.getMessage());
                     }
                     socket.close();
                 }
             } catch (NoSuchMethodError e) {
-                LOG.log(Level.FINE, "socket.isClosed is not supported by JDK1.3");
+                LOG.debug("socket.isClosed is not supported by JDK1.3");
                 try {
                     socket.leaveGroup(groupMulticastAddress);
                 } catch (IOException ex) {
-                    LOG.log(Level.SEVERE, "Error leaving multicast group. Message was " + ex.getMessage());
+                    LOG.error("Error leaving multicast group. Message was " + ex.getMessage());
                 }
                 socket.close();
             }
@@ -270,7 +271,7 @@
      */
     public static void setHeartBeatInterval(long heartBeatInterval) {
         if (heartBeatInterval < MINIMUM_HEARTBEAT_INTERVAL) {
-            LOG.log(Level.WARNING, "Trying to set heartbeat interval too low. Using MINIMUM_HEARTBEAT_INTERVAL instead.");
+            LOG.warn("Trying to set heartbeat interval too low. Using MINIMUM_HEARTBEAT_INTERVAL instead.");
             MulticastKeepaliveHeartbeatSender.heartBeatInterval = MINIMUM_HEARTBEAT_INTERVAL;
         } else {
             MulticastKeepaliveHeartbeatSender.heartBeatInterval = heartBeatInterval;
Index: src/main/java/net/sf/ehcache/distribution/PayloadUtil.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/PayloadUtil.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/PayloadUtil.java	(working copy)
@@ -22,11 +22,12 @@
 import java.io.IOException;
 import java.rmi.RemoteException;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * This class provides utility methods for assembling and disassembling a heartbeat payload.
  * <p/>
@@ -53,7 +54,7 @@
      */
     public static final String URL_DELIMITER = "|";
 
-    private static final Logger LOG = Logger.getLogger(PayloadUtil.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(PayloadUtil.class);
 
 
     /**
@@ -77,7 +78,7 @@
             try {
                 rmiUrl = cachePeer.getUrl();
             } catch (RemoteException e) {
-                LOG.log(Level.SEVERE, "This should never be thrown as it is called locally");
+                LOG.error("This should never be thrown as it is called locally");
             }
             if (i != localCachePeers.size() - 1) {
                 sb.append(rmiUrl).append(URL_DELIMITER);
@@ -85,9 +86,7 @@
                 sb.append(rmiUrl);
             }
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Cache peers for this CacheManager to be advertised: " + sb);
-        }
+        LOG.debug("Cache peers for this CacheManager to be advertised: {}", sb);
         return sb.toString().getBytes();
     }
 
@@ -103,7 +102,7 @@
             gzipOutputStream.write(ungzipped);
             gzipOutputStream.close();
         } catch (IOException e) {
-            LOG.log(Level.SEVERE, "Could not gzip " + ungzipped);
+            LOG.error("Could not gzip {}", ungzipped);
         }
         return bytes.toByteArray();
     }
@@ -135,7 +134,7 @@
             inputStream.close();
             byteArrayOutputStream.close();
         } catch (IOException e) {
-            LOG.log(Level.SEVERE, "Could not ungzip. Heartbeat will not be working. " + e.getMessage());
+            LOG.error("Could not ungzip. Heartbeat will not be working. {}", e.getMessage());
         }
         return ungzipped;
     }
Index: src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListenerFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListenerFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListenerFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheManager;
-
 import java.util.Properties;
 
+import net.sf.ehcache.CacheManager;
+
 /**
  * An abstract factory for creating cache manager peer listeners. Implementers should provide their own
  * concrete factory extending this factory. It can then be configured in ehcache.xml
Index: src/main/java/net/sf/ehcache/distribution/CachePeer.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/CachePeer.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/CachePeer.java	(working copy)
@@ -16,13 +16,13 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.Element;
-
 import java.io.Serializable;
 import java.rmi.Remote;
 import java.rmi.RemoteException;
 import java.util.List;
 
+import net.sf.ehcache.Element;
+
 /**
  * An interface for a cache peer to which updates are made remotely. The distribution mechanism
  * is meant to be pluggable. The requirements of RMI force this interface to exten Remote and
Index: src/main/java/net/sf/ehcache/distribution/RMICacheReplicatorFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICacheReplicatorFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICacheReplicatorFactory.java	(working copy)
@@ -16,13 +16,14 @@
 
 package net.sf.ehcache.distribution;
 
+import java.util.Properties;
+
 import net.sf.ehcache.event.CacheEventListener;
 import net.sf.ehcache.event.CacheEventListenerFactory;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -47,7 +48,7 @@
      */
     protected static final int DEFAULT_ASYNCHRONOUS_REPLICATION_INTERVAL_MILLIS = 1000;
 
-    private static final Logger LOG = Logger.getLogger(RMICacheReplicatorFactory.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICacheReplicatorFactory.class);
     private static final String REPLICATE_PUTS = "replicatePuts";
     private static final String REPLICATE_PUTS_VIA_COPY = "replicatePutsViaCopy";
     private static final String REPLICATE_UPDATES = "replicateUpdates";
@@ -127,15 +128,15 @@
                 int asynchronousReplicationIntervalMillisCandidate =
                         Integer.parseInt(asynchronousReplicationIntervalMillisString);
                 if (asynchronousReplicationIntervalMillisCandidate < MINIMUM_REASONABLE_INTERVAL) {
-                    LOG.log(Level.FINE, "Trying to set the asynchronousReplicationIntervalMillis to an unreasonable number." +
+                    LOG.debug("Trying to set the asynchronousReplicationIntervalMillis to an unreasonable number." +
                             " Using the default instead.");
                     asynchronousReplicationIntervalMillis = DEFAULT_ASYNCHRONOUS_REPLICATION_INTERVAL_MILLIS;
                 } else {
                     asynchronousReplicationIntervalMillis = asynchronousReplicationIntervalMillisCandidate;
                 }
             } catch (NumberFormatException e) {
-                LOG.log(Level.WARNING, "Number format exception trying to set asynchronousReplicationIntervalMillis. " +
-                        "Using the default instead. String value was: '" + asynchronousReplicationIntervalMillisString + "'");
+                LOG.warn("Number format exception trying to set asynchronousReplicationIntervalMillis. " +
+                        "Using the default instead. String value was: '{}'", asynchronousReplicationIntervalMillisString);
                 asynchronousReplicationIntervalMillis = DEFAULT_ASYNCHRONOUS_REPLICATION_INTERVAL_MILLIS;
             }
         } else {
Index: src/main/java/net/sf/ehcache/distribution/RMISynchronousCacheReplicator.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMISynchronousCacheReplicator.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMISynchronousCacheReplicator.java	(working copy)
@@ -16,15 +16,16 @@
 
 package net.sf.ehcache.distribution;
 
+import java.io.Serializable;
+import java.util.List;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.Status;
 
-import java.io.Serializable;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Listens to {@link net.sf.ehcache.CacheManager} and {@link net.sf.ehcache.Cache} events and propagates those to
@@ -35,7 +36,7 @@
  */
 public class RMISynchronousCacheReplicator implements CacheReplicator {
 
-    private static final Logger LOG = Logger.getLogger(RMISynchronousCacheReplicator.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMISynchronousCacheReplicator.class);
 
 
     /**
@@ -121,8 +122,8 @@
         }
 
         if (!element.isSerializable()) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "Object with key " + element.getObjectKey() + " is not Serializable and cannot be replicated");
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("Object with key {} is not Serializable and cannot be replicated", element.getObjectKey());
             }
             return;
         }
@@ -147,7 +148,7 @@
             try {
                 cachePeer.put(element);
             } catch (Throwable t) {
-                LOG.log(Level.SEVERE, "Exception on replication of putNotification. "
+                LOG.error("Exception on replication of putNotification. "
                         + t.getMessage() + ". Continuing...", t);
             }
         }
@@ -177,18 +178,15 @@
 
         if (replicateUpdatesViaCopy) {
             if (!element.isSerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Object with key " + element.getObjectKey()
-                            + " is not Serializable and cannot be updated via copy");
-                }
+                LOG.warn("Object with key {} is not Serializable and cannot be updated via copy", element.getObjectKey());
                 return;
             }
 
             replicatePutNotification(cache, element);
         } else {
             if (!element.isKeySerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Key " + element.getObjectKey() + " is not Serializable and cannot be replicated.");
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn("Key {} is not Serializable and cannot be replicated.", element.getObjectKey());
                 }
                 return;
             }
@@ -220,8 +218,8 @@
         }
 
         if (!element.isKeySerializable()) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "Key " + element.getObjectKey() + " is not Serializable and cannot be replicated.");
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("Key {} is not Serializable and cannot be replicated.", element.getObjectKey());
             }
             return;
         }
@@ -242,7 +240,7 @@
             try {
                 cachePeer.remove(key);
             } catch (Throwable t) {
-                LOG.log(Level.SEVERE, "Exception on replication of removeNotification. "
+                LOG.error("Exception on replication of removeNotification. "
                         + t.getMessage() + ". Continuing...", t);
             }
         }
@@ -320,7 +318,7 @@
             try {
                 cachePeer.removeAll();
             } catch (Throwable t) {
-                LOG.log(Level.SEVERE, "Exception on replication of removeAllNotification. "
+                LOG.error("Exception on replication of removeAllNotification. "
                         + t.getMessage() + ". Continuing...", t);
             }
         }
Index: src/main/java/net/sf/ehcache/distribution/MulticastRMICacheManagerPeerProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/MulticastRMICacheManagerPeerProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/MulticastRMICacheManagerPeerProvider.java	(working copy)
@@ -16,10 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.rmi.NotBoundException;
@@ -27,8 +23,13 @@
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A peer provider which discovers peers using Multicast.
@@ -61,7 +62,7 @@
      */
     protected static final int SHORT_DELAY = 100;
 
-    private static final Logger LOG = Logger.getLogger(MulticastRMICacheManagerPeerProvider.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(MulticastRMICacheManagerPeerProvider.class);
 
 
     private final MulticastKeepaliveHeartbeatReceiver heartBeatReceiver;
@@ -94,7 +95,7 @@
             heartBeatReceiver.init();
             heartBeatSender.init();
         } catch (IOException exception) {
-            LOG.log(Level.SEVERE, "Error starting heartbeat. Error was: " + exception.getMessage(), exception);
+            LOG.error("Error starting heartbeat. Error was: " + exception.getMessage(), exception);
             throw new CacheException(exception.getMessage());
         }
     }
@@ -119,21 +120,20 @@
                 cachePeerEntry.date = new Date();
             }
         } catch (IOException e) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Unable to lookup remote cache peer for " + rmiUrl + ". Removing from peer list. Cause was: "
-                        + e.getMessage());
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Unable to lookup remote cache peer for {}. Removing from peer list. Cause was: {}", rmiUrl, 
+                        e.getMessage());
             }
             unregisterPeer(rmiUrl);
         } catch (NotBoundException e) {
             peerUrls.remove(rmiUrl);
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Unable to lookup remote cache peer for " + rmiUrl + ". Removing from peer list. Cause was: "
-                        + e.getMessage());
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Unable to lookup remote cache peer for {}. Removing from peer list. Cause was: {}", rmiUrl,
+                        e.getMessage());
             }
         } catch (Throwable t) {
-            LOG.log(Level.SEVERE, "Unable to lookup remote cache peer for " + rmiUrl
-                    + ". Cause was not due to an IOException or NotBoundException which will occur in normal operation:" +
-                    " " + t.getMessage());
+            LOG.error("Unable to lookup remote cache peer for {}. Cause was not due to an IOException or" +
+                    " NotBoundException which will occur in normal operation:{}", rmiUrl, t.getMessage());
         }
     }
 
@@ -157,14 +157,12 @@
                         CachePeer cachePeer = cachePeerEntry.cachePeer;
                         remoteCachePeers.add(cachePeer);
                     } else {
-                        if (LOG.isLoggable(Level.FINE)) {
-                            LOG.log(Level.FINE, "rmiUrl " + rmiUrl + " is stale. Either the remote peer is shutdown or the " +
-                                    "network connectivity has been interrupted. Will be removed from list of remote cache peers");
-                        }
+                        LOG.debug("rmiUrl {} is stale. Either the remote peer is shutdown or the " +
+                                "network connectivity has been interrupted. Will be removed from list of remote cache peers", rmiUrl);
                         staleList.add(rmiUrl);
                     }
                 } catch (Exception exception) {
-                    LOG.log(Level.SEVERE, exception.getMessage(), exception);
+                    LOG.error(exception.getMessage(), exception);
                     throw new CacheException("Unable to list remote cache peers. Error was " + exception.getMessage());
                 }
             }
Index: src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListener.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListener.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerListener.java	(working copy)
@@ -16,12 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Status;
-import net.sf.ehcache.event.CacheEventListener;
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.ServerSocket;
@@ -40,8 +34,15 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Status;
+import net.sf.ehcache.event.CacheEventListener;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A cache server which exposes available cache operations remotely through RMI.
@@ -69,7 +70,7 @@
  */
 public class RMICacheManagerPeerListener implements CacheManagerPeerListener {
 
-    private static final Logger LOG = Logger.getLogger(RMICacheManagerPeerListener.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICacheManagerPeerListener.class);
     private static final int MINIMUM_SENSIBLE_TIMEOUT = 200;
     private static final int NAMING_UNBIND_RETRY_INTERVAL = 400;
     private static final int NAMING_UNBIND_MAX_RETRIES = 10;
@@ -116,7 +117,7 @@
         if (hostName != null && hostName.length() != 0) {
             this.hostName = hostName;
             if (hostName.equals("localhost")) {
-                LOG.log(Level.WARNING, "Explicitly setting the listener hostname to 'localhost' is not recommended. "
+                LOG.warn("Explicitly setting the listener hostname to 'localhost' is not recommended. "
                         + "It will only work if all CacheManager peers are on the same machine.");
             }
         } else {
@@ -150,9 +151,9 @@
         }
         this.port = new Integer(this.getFreePort());
         if (forced) {
-            LOG.log(Level.WARNING, "Resolving RMI port conflict by automatically using a free TCP/IP port to listen on: " + this.port);
+            LOG.warn("Resolving RMI port conflict by automatically using a free TCP/IP port to listen on: " + this.port);
         } else {
-            LOG.log(Level.FINE, "Automatically finding a free TCP/IP port to listen on: " + this.port);
+            LOG.debug("Automatically finding a free TCP/IP port to listen on: {}", this.port);
         }
     }
 
@@ -185,7 +186,7 @@
                 try {
                     serverSocket.close();
                 } catch (Exception e) {
-                    LOG.log(Level.FINE, "Error closing ServerSocket: " + e.getMessage());
+                    LOG.debug("Error closing ServerSocket: {}", e.getMessage());
                 }
             }
         }
@@ -211,7 +212,7 @@
                     counter++;
                 }
             }
-            LOG.log(Level.FINE, counter + " RMICachePeers bound in registry for RMI listener");
+            LOG.debug("{} RMICachePeers bound in registry for RMI listener", counter);
             status = Status.STATUS_ALIVE;
         } catch (Exception e) {
             String url = null;
@@ -321,7 +322,7 @@
                 registryCreated = true;
             }
         } catch (ExportException exception) {
-            LOG.log(Level.SEVERE, "Exception starting RMI registry. Error was " + exception.getMessage(), exception);
+            LOG.error("Exception starting RMI registry. Error was " + exception.getMessage(), exception);
         }
     }
 
@@ -337,9 +338,9 @@
             // thrown otherwise
             boolean success = UnicastRemoteObject.unexportObject(registry, true);
             if (success) {
-                LOG.log(Level.FINE, "rmiregistry unexported.");
+                LOG.debug("rmiregistry unexported.");
             } else {
-                LOG.log(Level.WARNING, "Could not unexport rmiregistry.");
+                LOG.warn("Could not unexport rmiregistry.");
             }
         }
     }
@@ -365,7 +366,7 @@
                 }
                 stopRegistry();
             }
-            LOG.log(Level.FINE, counter + " RMICachePeers unbound from registry in RMI listener");
+            LOG.debug("{} RMICachePeers unbound from registry in RMI listener", counter);
             status = Status.STATUS_SHUTDOWN;
         } catch (Exception e) {
             throw new CacheException("Problem unbinding remote cache peers. Initial cause was " + e.getMessage(), e);
@@ -405,7 +406,7 @@
         try {
             Naming.unbind(url);
         } catch (NotBoundException e) {
-            LOG.log(Level.WARNING, url + " not bound therefore not unbinding.");
+            LOG.warn(url + " not bound therefore not unbinding.");
         }
         // Try to gracefully unexport before forcing it.
         boolean unexported = UnicastRemoteObject.unexportObject(rmiCachePeer, false);
@@ -423,7 +424,7 @@
         // as a last resort.
         if (!unexported) {
             if (!UnicastRemoteObject.unexportObject(rmiCachePeer, true)) {
-                LOG.log(Level.WARNING, "Unable to unexport rmiCachePeer: " + rmiCachePeer.getUrl() + ".  Skipping.");
+                LOG.warn("Unable to unexport rmiCachePeer: " + rmiCachePeer.getUrl() + ".  Skipping.");
             }
         }
     }
@@ -506,9 +507,7 @@
      */
     public void notifyCacheAdded(String cacheName) throws CacheException {
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Adding " + cacheName + " to RMI listener");
-        }
+        LOG.debug("Adding {} to RMI listener", cacheName);
 
         //Don't add if exists.
         synchronized (cachePeers) {
@@ -535,9 +534,7 @@
             }
 
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, cachePeers.size() + " RMICachePeers bound in registry for RMI listener");
-        }
+        LOG.debug("{} RMICachePeers bound in registry for RMI listener", cachePeers.size());
     }
 
     /**
@@ -554,9 +551,7 @@
      */
     public void notifyCacheRemoved(String cacheName) {
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Removing " + cacheName + " from RMI listener");
-        }
+        LOG.debug("Removing {} from RMI listener", cacheName);
 
         //don't remove if already removed.
         synchronized (cachePeers) {
@@ -577,9 +572,7 @@
                     + url + " from listener. Message was: " + e.getMessage(), e);
         }
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, cachePeers.size() + " RMICachePeers bound in registry for RMI listener");
-        }
+        LOG.debug("{} RMICachePeers bound in registry for RMI listener", cachePeers.size());
     }
 
 
Index: src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMICacheManagerPeerProvider.java	(working copy)
@@ -16,10 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-
 import java.net.MalformedURLException;
 import java.rmi.Naming;
 import java.rmi.NotBoundException;
@@ -29,8 +25,12 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.logging.Logger;
 import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
 
 /**
  * A provider of Peer RMI addresses.
Index: src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderFactory.java	(working copy)
@@ -16,13 +16,14 @@
 
 package net.sf.ehcache.distribution;
 
+import java.util.Properties;
+
 import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
 import net.sf.ehcache.bootstrap.BootstrapCacheLoaderFactory;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -58,7 +59,7 @@
      */
     protected static final int FIVE_KB = 5000;
 
-    private static final Logger LOG = Logger.getLogger(RMIBootstrapCacheLoaderFactory.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMIBootstrapCacheLoaderFactory.class);
 
 
     /**
@@ -85,13 +86,13 @@
             try {
                 int maximumChunkSizeBytesCandidate = Integer.parseInt(maximumChunkSizeBytesString);
                 if ((maximumChunkSizeBytesCandidate < FIVE_KB) || (maximumChunkSizeBytesCandidate > ONE_HUNDRED_MB)) {
-                    LOG.log(Level.WARNING, "Trying to set the chunk size to an unreasonable number. Using the default instead.");
+                    LOG.warn("Trying to set the chunk size to an unreasonable number. Using the default instead.");
                     maximumChunkSizeBytes = DEFAULT_MAXIMUM_CHUNK_SIZE_BYTES;
                 } else {
                     maximumChunkSizeBytes = maximumChunkSizeBytesCandidate;
                 }
             } catch (NumberFormatException e) {
-                LOG.log(Level.WARNING, "Number format exception trying to set chunk size. Using the default instead.");
+                LOG.warn("Number format exception trying to set chunk size. Using the default instead.");
                 maximumChunkSizeBytes = DEFAULT_MAXIMUM_CHUNK_SIZE_BYTES;
             }
 
Index: src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoader.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoader.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoader.java	(working copy)
@@ -16,17 +16,18 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
-
 import java.io.Serializable;
 import java.rmi.RemoteException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Loads Elements from a random Cache Peer
@@ -38,7 +39,7 @@
 
     private static final int ONE_SECOND = 1000;
 
-    private static final Logger LOG = Logger.getLogger(RMIBootstrapCacheLoader.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMIBootstrapCacheLoader.class);
 
     /**
      * Whether to load asynchronously
@@ -105,7 +106,7 @@
             try {
                 doLoad(cache);
             } catch (RemoteCacheException e) {
-                LOG.log(Level.WARNING, "Error asynchronously performing bootstrap. The cause was: " + e.getMessage(), e);
+                LOG.warn("Error asynchronously performing bootstrap. The cause was: " + e.getMessage(), e);
             } finally {
                 cache = null;
             }
@@ -130,13 +131,15 @@
 
         List cachePeers = acquireCachePeers(cache);
         if (cachePeers == null || cachePeers.size() == 0) {
-            LOG.log(Level.FINE, "Empty list of cache peers for cache " + cache.getName() + ". No cache peer to bootstrap from.");
+            LOG.debug("Empty list of cache peers for cache {}. No cache peer to bootstrap from.", cache.getName());
             return;
         }
         Random random = new Random();
         int randomPeerNumber = random.nextInt(cachePeers.size());
         CachePeer cachePeer = (CachePeer) cachePeers.get(randomPeerNumber);
-        LOG.log(Level.FINE, "Bootstrapping " + cache.getName() + " from " + cachePeer);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Bootstrapping {} from {}", cache.getName(), cachePeer);
+        }
 
         try {
 
@@ -151,8 +154,10 @@
                 }
             }
             if (sampleElement == null) {
-                LOG.log(Level.FINE, "All cache peer elements were either null or empty. Nothing to bootstrap from. Cache was "
-                        + cache.getName() + ". Cache peer was " + cachePeer);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("All cache peer elements were either null or empty. Nothing to bootstrap from. Cache was "
+                            + "{}. Cache peer was {}", cache.getName(), cachePeer);
+                }
                 return;
             }
             long size = sampleElement.getSerializedSize();
@@ -169,8 +174,9 @@
             }
             //get leftovers
             fetchAndPutElements(cache, requestChunk, cachePeer);
-            LOG.log(Level.FINE, "Bootstrap of " + cache.getName() + " from " + cachePeer + " finished. "
-                    + keys.size() + " keys requested.");
+            
+            LOG.debug("Bootstrap of {} from {} finished. {} keys requested.",
+                    new Object[]{cache.getName(), cachePeer, keys.size()});
         } catch (Throwable t) {
             throw new RemoteCacheException("Error bootstrapping from remote peer. Message was: " + t.getMessage(), t);
         }
@@ -188,10 +194,8 @@
         if (cacheManagerPeerProvider != null) {
             timeForClusterToForm = cacheManagerPeerProvider.getTimeForClusterToForm();
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Attempting to acquire cache peers for cache " + cache.getName()
-                    + " to bootstrap from. Will wait up to " + timeForClusterToForm + "ms for cache to join cluster.");
-        }
+        LOG.debug("Attempting to acquire cache peers for cache {} to bootstrap from. Will wait up to {}ms" +
+                " for cache to join cluster.", cache.getName(), timeForClusterToForm);
         List cachePeers = null;
         for (int i = 0; i <= timeForClusterToForm; i = i + ONE_SECOND) {
             cachePeers = listRemoteCachePeers(cache);
@@ -204,12 +208,10 @@
             try {
                 Thread.sleep(ONE_SECOND);
             } catch (InterruptedException e) {
-                LOG.log(Level.FINE, "doLoad for " + cache.getName() + " interrupted.");
+                LOG.debug("doLoad for {} interrupted.", cache.getName());
             }
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "cache peers: " + cachePeers);
-        }
+        LOG.debug("cache peers: {}", cachePeers);
         return cachePeers;
     }
 
Index: src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListener.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListener.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/CacheManagerPeerListener.java	(working copy)
@@ -16,11 +16,11 @@
 
 package net.sf.ehcache.distribution;
 
+import java.util.List;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.event.CacheManagerEventListener;
 
-import java.util.List;
-
 /**
  * A listener for updates, which controls remote cache peers.
  * @author Greg Luck
Index: src/main/java/net/sf/ehcache/distribution/RMIAsynchronousCacheReplicator.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/RMIAsynchronousCacheReplicator.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/RMIAsynchronousCacheReplicator.java	(working copy)
@@ -16,18 +16,19 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.Status;
-
 import java.io.Serializable;
 import java.rmi.UnmarshalException;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.Status;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Listens to {@link net.sf.ehcache.CacheManager} and {@link net.sf.ehcache.Cache} events and propagates those to
@@ -55,7 +56,7 @@
 public class RMIAsynchronousCacheReplicator extends RMISynchronousCacheReplicator {
 
 
-    private static final Logger LOG = Logger.getLogger(RMIAsynchronousCacheReplicator.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMIAsynchronousCacheReplicator.class);
 
     /**
      * A thread which handles replication, so that replication can take place asynchronously and not hold up the cache
@@ -105,7 +106,7 @@
                 try {
                     Thread.sleep(asynchronousReplicationInterval);
                 } catch (InterruptedException e) {
-                    LOG.log(Level.FINE, "Spool Thread interrupted.");
+                    LOG.debug("Spool Thread interrupted.");
                     return;
                 }
             }
@@ -117,7 +118,7 @@
                     flushReplicationQueue();
                 }
             } catch (Throwable e) {
-                LOG.log(Level.SEVERE, "Exception on flushing of replication queue: " + e.getMessage()
+                LOG.error("Exception on flushing of replication queue: " + e.getMessage()
                         + ". Continuing...", e);
             }
         }
@@ -143,18 +144,15 @@
 
         if (replicatePutsViaCopy) {
             if (!element.isSerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Object with key " + element.getObjectKey()
-                            + " is not Serializable and cannot be replicated.");
-                }
+                LOG.warn("Object with key is not Serializable and cannot be replicated.");
                 return;
             }
             addToReplicationQueue(new CacheEventMessage(EventMessage.PUT, cache, element, null));
         } else {
             if (!element.isKeySerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Object with key " + element.getObjectKey()
-                            + " does not have a Serializable key and cannot be replicated via invalidate.");
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn("Object with key {} does not have a Serializable key and cannot be" +
+                            " replicated via invalidate.", element.getObjectKey());
                 }
                 return;
             }
@@ -186,18 +184,18 @@
 
         if (replicateUpdatesViaCopy) {
             if (!element.isSerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Object with key " + element.getObjectKey()
-                            + " is not Serializable and cannot be updated via copy.");
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn("Object with key {} is not Serializable and cannot be updated via copy.",
+                            element.getObjectKey());
                 }
                 return;
             }
             addToReplicationQueue(new CacheEventMessage(EventMessage.PUT, cache, element, null));
         } else {
             if (!element.isKeySerializable()) {
-                if (LOG.isLoggable(Level.WARNING)) {
-                    LOG.log(Level.WARNING, "Object with key " + element.getObjectKey()
-                            + " does not have a Serializable key and cannot be replicated via invalidate.");
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn("Object with key {} does not have a Serializable key and cannot be replicated " +
+                            "via invalidate.", element.getObjectKey());
                 }
                 return;
             }
@@ -228,8 +226,8 @@
         }
 
         if (!element.isKeySerializable()) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "Key " + element.getObjectKey() + " is not Serializable and cannot be replicated.");
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("Key {} is not Serializable and cannot be replicated.", element.getObjectKey());
             }
             return;
         }
@@ -272,7 +270,7 @@
      */
     protected void addToReplicationQueue(CacheEventMessage cacheEventMessage) {
         if (!replicationThread.isAlive()) {
-            LOG.log(Level.SEVERE, "CacheEventMessages cannot be added to the replication queue"
+            LOG.error("CacheEventMessages cannot be added to the replication queue"
                     + " because the replication thread has died.");
         } else {
             synchronized (replicationQueue) {
@@ -320,22 +318,24 @@
             } catch (UnmarshalException e) {
                 String message = e.getMessage();
                 if (message.indexOf("Read time out") != 0) {
-                    LOG.log(Level.WARNING, "Unable to send message to remote peer due to socket read timeout. Consider increasing" +
+                    LOG.warn("Unable to send message to remote peer due to socket read timeout. Consider increasing" +
                             " the socketTimeoutMillis setting in the cacheManagerPeerListenerFactory. " +
-                            "Message was: " + e.getMessage());
+                            "Message was: {}", e.getMessage());
                 } else {
-                    LOG.log(Level.FINE, "Unable to send message to remote peer.  Message was: " + e.getMessage());
+                    LOG.debug("Unable to send message to remote peer.  Message was: {}", e.getMessage());
                 }
             } catch (Throwable t) {
-                LOG.log(Level.WARNING, "Unable to send message to remote peer.  Message was: " + t.getMessage(), t);
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn("Unable to send message to remote peer.  Message was: " + t.getMessage(), t);
+                }
             }
         }
-        if (LOG.isLoggable(Level.WARNING)) {
+        if (LOG.isWarnEnabled()) {
             int eventMessagesNotResolved = replicationQueueCopy.size() - resolvedEventMessages.size();
             if (eventMessagesNotResolved > 0) {
-                LOG.log(Level.WARNING, eventMessagesNotResolved + " messages were discarded on replicate due to reclamation of " +
+                LOG.warn("{} messages were discarded on replicate due to reclamation of " +
                         "SoftReferences by the VM. Consider increasing the maximum heap size and/or setting the " +
-                        "starting heap size to a higher value.");
+                        "starting heap size to a higher value.", eventMessagesNotResolved);
             }
 
         }
Index: src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatReceiver.java
===================================================================
--- src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatReceiver.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/distribution/MulticastKeepaliveHeartbeatReceiver.java	(working copy)
@@ -16,8 +16,6 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.CacheManager;
-
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.InetAddress;
@@ -30,8 +28,11 @@
 import java.util.StringTokenizer;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheManager;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Receives heartbeats from any {@link MulticastKeepaliveHeartbeatSender}s out there.
@@ -43,7 +44,7 @@
  */
 public final class MulticastKeepaliveHeartbeatReceiver {
 
-    private static final Logger LOG = Logger.getLogger(MulticastKeepaliveHeartbeatReceiver.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(MulticastKeepaliveHeartbeatReceiver.class);
 
     private ExecutorService processingThreadPool;
     private Set rmiUrlsProcessingQueue = Collections.synchronizedSet(new HashSet());
@@ -93,7 +94,7 @@
      * Shutdown the heartbeat.
      */
     public final void dispose() {
-        LOG.log(Level.FINE, "dispose called");
+        LOG.debug("dispose called");
         processingThreadPool.shutdownNow();
         stopped = true;
         receiverThread.interrupt();
@@ -125,13 +126,13 @@
 
                     } catch (IOException e) {
                         if (!stopped) {
-                            LOG.log(Level.SEVERE, "Error receiving heartbeat. " + e.getMessage() +
+                            LOG.error("Error receiving heartbeat. " + e.getMessage() +
                                     ". Initial cause was " + e.getMessage(), e);
                         }
                     }
                 }
             } catch (Throwable t) {
-                LOG.log(Level.SEVERE, "Multicast receiver thread caught throwable. Cause was " + t.getMessage() + ". Continuing...");
+                LOG.error("Multicast receiver thread caught throwable. Cause was " + t.getMessage() + ". Continuing...");
             }
         }
 
@@ -142,9 +143,7 @@
                 return;
             }
             rmiUrls = rmiUrls.trim();
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.fine("rmiUrls received " + rmiUrls);
-            }
+            LOG.debug("rmiUrls received {}", rmiUrls);
             processRmiUrls(rmiUrls);
         }
 
@@ -158,9 +157,7 @@
          */
         private void processRmiUrls(final String rmiUrls) {
             if (rmiUrlsProcessingQueue.contains(rmiUrls)) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "We are already processing these rmiUrls. Another heartbeat came before we finished: " + rmiUrls);
-                }
+                LOG.debug("We are already processing these rmiUrls. Another heartbeat came before we finished: {}", rmiUrls);
                 return;
             }
 
@@ -181,9 +178,7 @@
                             String rmiUrl = stringTokenizer.nextToken();
                             registerNotification(rmiUrl);
                             if (!peerProvider.peerUrls.containsKey(rmiUrl)) {
-                                if (LOG.isLoggable(Level.FINE)) {
-                                    LOG.log(Level.FINE, "Aborting processing of rmiUrls since failed to add rmiUrl: " + rmiUrl);
-                                }
+                                LOG.debug("Aborting processing of rmiUrls since failed to add rmiUrl: {}", rmiUrl);
                                 return;
                             }
                         }
@@ -216,7 +211,7 @@
             try {
                 cacheManagerUrlBase = peer.getUrlBase();
             } catch (RemoteException e) {
-                LOG.log(Level.SEVERE, "Error geting url base");
+                LOG.error("Error geting url base");
             }
             int baseUrlMatch = rmiUrls.indexOf(cacheManagerUrlBase);
             return baseUrlMatch != -1;
@@ -234,7 +229,7 @@
             try {
                 socket.leaveGroup(groupMulticastAddress);
             } catch (IOException e) {
-                LOG.log(Level.SEVERE, "Error leaving group");
+                LOG.error("Error leaving group");
             }
             socket.close();
             super.interrupt();
Index: src/main/java/net/sf/ehcache/config/DiskStoreConfiguration.java
===================================================================
--- src/main/java/net/sf/ehcache/config/DiskStoreConfiguration.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/DiskStoreConfiguration.java	(working copy)
@@ -18,8 +18,9 @@
 
 
 import java.io.File;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A class to represent DiskStore configuration
@@ -30,7 +31,7 @@
  */
 public final class DiskStoreConfiguration {
 
-    private static final Logger LOG = Logger.getLogger(DiskStoreConfiguration.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(DiskStoreConfiguration.class);
 
 
     /**
@@ -95,9 +96,7 @@
         translatedPath = replaceToken(File.separator + File.separator, File.separator, translatedPath);
 
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Disk Store Path: " + translatedPath);
-        }
+        LOG.debug("Disk Store Path: {}", translatedPath);
         return translatedPath;
     }
 
Index: src/main/java/net/sf/ehcache/config/CacheConfiguration.java
===================================================================
--- src/main/java/net/sf/ehcache/config/CacheConfiguration.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/CacheConfiguration.java	(working copy)
@@ -16,11 +16,11 @@
 
 package net.sf.ehcache.config;
 
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-
 import java.util.ArrayList;
 import java.util.List;
 
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+
 /**
  * A value object to represent Cache configuration that can be set by the BeanHandler.
  *
Index: src/main/java/net/sf/ehcache/config/Configuration.java
===================================================================
--- src/main/java/net/sf/ehcache/config/Configuration.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/Configuration.java	(working copy)
@@ -16,14 +16,14 @@
 
 package net.sf.ehcache.config;
 
-import net.sf.ehcache.ObjectExistsException;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import net.sf.ehcache.ObjectExistsException;
+
 /**
  * A bean, used by BeanUtils, to set configuration from an XML configuration file.
  *
Index: src/main/java/net/sf/ehcache/config/ConfigurationHelper.java
===================================================================
--- src/main/java/net/sf/ehcache/config/ConfigurationHelper.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/ConfigurationHelper.java	(working copy)
@@ -16,6 +16,14 @@
 
 package net.sf.ehcache.config;
 
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
@@ -41,15 +49,8 @@
 import net.sf.ehcache.util.ClassLoaderUtil;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * The configuration for ehcache.
@@ -65,7 +66,7 @@
  */
 public final class ConfigurationHelper {
 
-    private static final Logger LOG = Logger.getLogger(ConfigurationHelper.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ConfigurationHelper.class);
 
     private Configuration configuration;
     private CacheManager cacheManager;
@@ -145,7 +146,7 @@
             className = factoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null) {
-            LOG.log(Level.FINE, "CacheEventListener factory not configured. Skipping...");
+            LOG.debug("CacheEventListener factory not configured. Skipping...");
         } else {
             CacheEventListenerFactory factory = (CacheEventListenerFactory)
                     ClassLoaderUtil.createNewInstance(className);
@@ -172,7 +173,7 @@
             className = factoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null) {
-            LOG.log(Level.FINE, "CacheExtension factory not configured. Skipping...");
+            LOG.debug("CacheExtension factory not configured. Skipping...");
         } else {
             CacheExtensionFactory factory = (CacheExtensionFactory) ClassLoaderUtil.createNewInstance(className);
             Properties properties = PropertyUtil.parseProperties(factoryConfiguration.getProperties(),
@@ -195,7 +196,7 @@
             className = factoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null) {
-            LOG.log(Level.FINE, "CacheLoader factory not configured. Skipping...");
+            LOG.debug("CacheLoader factory not configured. Skipping...");
         } else {
             CacheLoaderFactory factory = (CacheLoaderFactory) ClassLoaderUtil.createNewInstance(className);
             Properties properties = PropertyUtil.parseProperties(factoryConfiguration.getProperties(),
@@ -218,7 +219,7 @@
             className = factoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null || className.length() == 0) {
-            LOG.log(Level.FINE, "No BootstrapCacheLoaderFactory class specified. Skipping...");
+            LOG.debug("No BootstrapCacheLoaderFactory class specified. Skipping...");
         } else {
             BootstrapCacheLoaderFactory factory = (BootstrapCacheLoaderFactory)
                     ClassLoaderUtil.createNewInstance(className);
@@ -243,7 +244,7 @@
             className = factoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null || className.length() == 0) {
-            LOG.log(Level.FINE, "No CacheExceptionHandlerFactory class specified. Skipping...");
+            LOG.debug("No CacheExceptionHandlerFactory class specified. Skipping...");
         } else {
             CacheExceptionHandlerFactory factory = (CacheExceptionHandlerFactory)
                     ClassLoaderUtil.createNewInstance(className);
@@ -271,7 +272,7 @@
                 className = factoryConfiguration.getFullyQualifiedClassPath();
             }
             if (className == null) {
-                LOG.log(Level.FINE, "No CachePeerProviderFactoryConfiguration specified. Not configuring a CacheManagerPeerProvider.");
+                LOG.debug("No CachePeerProviderFactoryConfiguration specified. Not configuring a CacheManagerPeerProvider.");
                 return null;
             } else {
                 CacheManagerPeerProviderFactory cacheManagerPeerProviderFactory =
@@ -303,7 +304,7 @@
                 className = factoryConfiguration.getFullyQualifiedClassPath();
             }
             if (className == null) {
-                LOG.log(Level.FINE, "No CachePeerListenerFactoryConfiguration specified. Not configuring a CacheManagerPeerListener.");
+                LOG.debug("No CachePeerListenerFactoryConfiguration specified. Not configuring a CacheManagerPeerListener.");
                 return null;
             } else {
                 CacheManagerPeerListenerFactory cacheManagerPeerListenerFactory = (CacheManagerPeerListenerFactory)
@@ -331,7 +332,7 @@
             className = cacheManagerEventListenerFactoryConfiguration.getFullyQualifiedClassPath();
         }
         if (className == null || className.length() == 0) {
-            LOG.log(Level.FINE, "No CacheManagerEventListenerFactory class specified. Skipping...");
+            LOG.debug("No CacheManagerEventListenerFactory class specified. Skipping...");
             return null;
         } else {
             CacheManagerEventListenerFactory factory = (CacheManagerEventListenerFactory)
Index: src/main/java/net/sf/ehcache/config/BeanHandler.java
===================================================================
--- src/main/java/net/sf/ehcache/config/BeanHandler.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/BeanHandler.java	(working copy)
@@ -16,18 +16,18 @@
 
 package net.sf.ehcache.config;
 
-import org.xml.sax.Attributes;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-import org.xml.sax.helpers.DefaultHandler;
-
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.Attributes;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
 
 /**
  * A SAX handler that configures a bean.
@@ -38,7 +38,7 @@
  */
 final class BeanHandler extends DefaultHandler {
 
-    private static final Logger LOG = Logger.getLogger(BeanHandler.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(BeanHandler.class);
     private final Object bean;
     private ElementInfo element;
     private Locator locator;
@@ -210,9 +210,7 @@
             } else {
                 //allow references to an XML schema but do not use it
                 if (element.elementName.equals("ehcache")) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Ignoring ehcache attribute " + attrName);
-                    }
+                    LOG.debug("Ignoring ehcache attribute {}", attrName);
                     return;
                 }
             }
Index: src/main/java/net/sf/ehcache/config/ConfigurationFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/config/ConfigurationFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/config/ConfigurationFactory.java	(working copy)
@@ -16,11 +16,6 @@
 
 package net.sf.ehcache.config;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.util.ClassLoaderUtil;
-
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -32,11 +27,18 @@
 import java.net.URL;
 import java.util.HashSet;
 import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.util.ClassLoaderUtil;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * A utility class which configures beans from XML, using reflection.
  *
@@ -45,7 +47,7 @@
  */
 public final class ConfigurationFactory {
 
-    private static final Logger LOG = Logger.getLogger(ConfigurationFactory.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ConfigurationFactory.class);
 
     private static final String DEFAULT_CLASSPATH_CONFIGURATION_FILE = "/ehcache.xml";
     private static final String FAILSAFE_CLASSPATH_CONFIGURATION_FILE = "/ehcache-failsafe.xml";
@@ -65,9 +67,7 @@
             throw new CacheException("Attempt to configure ehcache from null file.");
         }
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Configuring ehcache from file: " + file.toString());
-        }
+        LOG.debug("Configuring ehcache from file: {}", file.toString());
         Configuration configuration = null;
         InputStream input = null;
         try {
@@ -81,7 +81,7 @@
                     input.close();
                 }
             } catch (IOException e) {
-                LOG.log(Level.SEVERE, "IOException while closing configuration input stream. Error was " + e.getMessage());
+                LOG.error("IOException while closing configuration input stream. Error was {}", e.getMessage());
             }
         }
         return configuration;
@@ -91,9 +91,7 @@
      * Configures a bean from an XML file available as an URL.
      */
     public static Configuration parseConfiguration(final URL url) throws CacheException {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Configuring ehcache from URL: " + url);
-        }
+        LOG.debug("Configuring ehcache from URL: {}", url);
         Configuration configuration;
         InputStream input = null;
         try {
@@ -107,7 +105,7 @@
                     input.close();
                 }
             } catch (IOException e) {
-                LOG.log(Level.SEVERE, "IOException while closing configuration input stream. Error was " + e.getMessage());
+                LOG.error("IOException while closing configuration input stream. Error was {}", e.getMessage());
             }
         }
         return configuration;
@@ -126,15 +124,11 @@
             url = ConfigurationFactory.class.getResource(DEFAULT_CLASSPATH_CONFIGURATION_FILE);
         }
         if (url != null) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Configuring ehcache from ehcache.xml found in the classpath: " + url);
-            }
+            LOG.debug("Configuring ehcache from ehcache.xml found in the classpath: {}", url);
         } else {
             url = ConfigurationFactory.class.getResource(FAILSAFE_CLASSPATH_CONFIGURATION_FILE);
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "No configuration found. Configuring ehcache from ehcache-failsafe.xml "
-                        + " found in the classpath: " + url);
-            }
+            LOG.warn("No configuration found. Configuring ehcache from ehcache-failsafe.xml "
+                    + " found in the classpath: {}", url);
         }
         return parseConfiguration(url);
     }
@@ -143,9 +137,7 @@
      * Configures a bean from an XML input stream.
      */
     public static Configuration parseConfiguration(final InputStream inputStream) throws CacheException {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Configuring ehcache from InputStream");
-        }
+        LOG.debug("Configuring ehcache from InputStream");
 
         Configuration configuration = new Configuration();
         try {
@@ -186,18 +178,14 @@
 
             String property = System.getProperty(trimmedToken);
             if (property == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Did not find a system property for the " + token +
-                            " token specified in the configuration.Replacing with \"\"");
-                }
+                LOG.debug("Did not find a system property for the {}" +
+                        " token specified in the configuration.Replacing with \"\"", token);
             } else {
                 //replaceAll by default clobbers \ and $
                 String propertyWithQuotesProtected = Matcher.quoteReplacement(property);
                 configuration = configuration.replaceAll("\\$\\{" + trimmedToken + "\\}", propertyWithQuotesProtected);
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Found system property value of " + property + " for the " + token +
-                            " token specified in the configuration.");
-                }
+                LOG.debug("Found system property value of {} for the {}" +
+                        " token specified in the configuration.", property, token);
             }
         }
         return new ByteArrayInputStream(configuration.getBytes());
Index: src/main/java/net/sf/ehcache/loader/CacheLoaderFactory.java
===================================================================
--- src/main/java/net/sf/ehcache/loader/CacheLoaderFactory.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/loader/CacheLoaderFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.loader;
 
-import net.sf.ehcache.Ehcache;
-
 import java.util.Properties;
 
+import net.sf.ehcache.Ehcache;
+
 /**
  * An abstract factory for creating cache loaders. Implementers should provide their own
  * concrete factory extending this factory.
Index: src/main/java/net/sf/ehcache/loader/CacheLoader.java
===================================================================
--- src/main/java/net/sf/ehcache/loader/CacheLoader.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/loader/CacheLoader.java	(working copy)
@@ -16,13 +16,13 @@
 
 package net.sf.ehcache.loader;
 
+import java.util.Collection;
+import java.util.Map;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Status;
 
-import java.util.Collection;
-import java.util.Map;
-
 /**
  * Extends JCache CacheLoader with load methods that take an argument in addition to a key
  *
Index: src/main/java/net/sf/ehcache/exceptionhandler/ExceptionHandlingDynamicCacheProxy.java
===================================================================
--- src/main/java/net/sf/ehcache/exceptionhandler/ExceptionHandlingDynamicCacheProxy.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/exceptionhandler/ExceptionHandlingDynamicCacheProxy.java	(working copy)
@@ -16,14 +16,15 @@
 
 package net.sf.ehcache.exceptionhandler;
 
-import net.sf.ehcache.Ehcache;
-
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
+import net.sf.ehcache.Ehcache;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * A dynamic proxy which provides CacheException handling.
@@ -51,7 +52,7 @@
  */
 public final class ExceptionHandlingDynamicCacheProxy implements InvocationHandler {
 
-    private static final Logger LOG = Logger.getLogger(ExceptionHandlingDynamicCacheProxy.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ExceptionHandlingDynamicCacheProxy.class);
 
     private Ehcache ehcache;
 
@@ -143,9 +144,7 @@
                     causeAsException = (Exception) cause;
                 } catch (ClassCastException cce) {
                     //we only handle exceptions, not errors.
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Underlying cause was not an Exception: " + cce);
-                    }
+                    LOG.debug("Underlying cause was not an Exception: ", cce);
                 }
 
                 cacheExceptionHandler.onException(ehcache, keyAsString, causeAsException);
Index: src/main/java/net/sf/ehcache/hibernate/SingletonEhCacheProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/hibernate/SingletonEhCacheProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/hibernate/SingletonEhCacheProvider.java	(working copy)
@@ -15,17 +15,18 @@
  */
 package net.sf.ehcache.hibernate;
 
+import java.net.URL;
+import java.util.Properties;
+
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.util.ClassLoaderUtil;
+
 import org.hibernate.cache.Cache;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.CacheProvider;
 import org.hibernate.cache.Timestamper;
-
-import java.net.URL;
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Singleton cache Provider plugin for Hibernate 3.2 and ehcache-1.2. New in this provider is support for
@@ -59,7 +60,7 @@
      */
     public static final String NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME = "net.sf.ehcache.configurationResourceName";
 
-    private static final Logger LOG = Logger.getLogger(SingletonEhCacheProvider.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(SingletonEhCacheProvider.class);
 
     /**
      * To be backwardly compatible with a lot of Hibernate code out there, allow multiple starts and stops on the
@@ -88,11 +89,11 @@
         try {
             net.sf.ehcache.Ehcache cache = manager.getEhcache(name);
             if (cache == null) {
-                SingletonEhCacheProvider.LOG.log(Level.WARNING, "Could not find a specific ehcache configuration for cache named ["
-                        + name + "]; using defaults.");
+                SingletonEhCacheProvider.LOG.warn("Could not find a specific ehcache configuration for cache named" +
+                        " [{}]; using defaults.", name);
                 manager.addCache(name);
                 cache = manager.getEhcache(name);
-                SingletonEhCacheProvider.LOG.log(Level.FINE, "started EHCache region: " + name);
+                SingletonEhCacheProvider.LOG.debug("started EHCache region: {}", name);
             }
             return new EhCache(cache);
         } catch (net.sf.ehcache.CacheException e) {
@@ -125,10 +126,8 @@
         } else {
             if (!configurationResourceName.startsWith("/")) {
                 configurationResourceName = "/" + configurationResourceName;
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "prepending / to " + configurationResourceName + ". It should be placed in the root"
-                            + "of the classpath rather than in a package.");
-                }
+                LOG.debug("prepending / to {}. It should be placed in the root"
+                        + "of the classpath rather than in a package.", configurationResourceName);
             }
             URL url = loadResource(configurationResourceName);
             manager = CacheManager.create(url);
@@ -145,16 +144,12 @@
         if (url == null) {
             url = this.getClass().getResource(configurationResourceName);
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Creating EhCacheProvider from a specified resource: "
-                    + configurationResourceName + " Resolved to URL: " + url);
-        }
+        LOG.debug("Creating EhCacheProvider from a specified resource: {}" +
+                " Resolved to URL: {}", configurationResourceName , url);
         if (url == null) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "A configurationResourceName was set to " + configurationResourceName +
-                        " but the resource could not be loaded from the classpath." +
-                        "Ehcache will configure itself using defaults.");
-            }
+            LOG.warn("A configurationResourceName was set to {} but the resource" +
+                    " could not be loaded from the classpath. Ehcache will configure" +
+                    " itself using defaults.", configurationResourceName);
         }
         return url;
     }
Index: src/main/java/net/sf/ehcache/hibernate/EhCache.java
===================================================================
--- src/main/java/net/sf/ehcache/hibernate/EhCache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/hibernate/EhCache.java	(working copy)
@@ -16,16 +16,17 @@
 package net.sf.ehcache.hibernate;
 
 
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
 import net.sf.ehcache.Element;
+
 import org.hibernate.cache.Cache;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.Timestamper;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * EHCache plugin for Hibernate.
@@ -44,7 +45,7 @@
  */
 public final class EhCache implements Cache {
 
-    private static final Logger LOG = Logger.getLogger(EhCache.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(EhCache.class);
 
     private static final int SIXTY_THOUSAND_MS = 60000;
 
@@ -73,17 +74,13 @@
      */
     public final Object get(Object key) throws CacheException {
         try {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "key: " + key);
-            }
+            LOG.debug("key: {}", key);
             if (key == null) {
                 return null;
             } else {
                 Element element = cache.get(key);
                 if (element == null) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Element for " + key + " is null");
-                    }
+                    LOG.debug("Element for {} is null", key);
                     return null;
                 } else {
                     return element.getObjectValue();
@@ -125,9 +122,7 @@
      * @throws CacheException if the {@link net.sf.ehcache.CacheManager} is shutdown or another {@link Exception} occurs.
      */
     public final void put(Object key, Object value) throws CacheException {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "key: " + key + " value: " + value);
-        }
+        LOG.debug("key: {} value: {}", key, value);
         
         try {
             Element element = new Element(key, value);
@@ -183,9 +178,7 @@
         } catch (IllegalStateException e) {
             //When Spring and Hibernate are both involved this will happen in normal shutdown operation.
             //Do not throw an exception, simply log this one.
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "This can happen if multiple frameworks both try to shutdown ehcache", e);
-            }
+            LOG.debug("This can happen if multiple frameworks both try to shutdown ehcache", e);
         } catch (net.sf.ehcache.CacheException e) {
             throw new CacheException(e);
         }
Index: src/main/java/net/sf/ehcache/hibernate/EhCacheProvider.java
===================================================================
--- src/main/java/net/sf/ehcache/hibernate/EhCacheProvider.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/hibernate/EhCacheProvider.java	(working copy)
@@ -15,17 +15,18 @@
  */
 package net.sf.ehcache.hibernate;
 
+import java.net.URL;
+import java.util.Properties;
+
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.util.ClassLoaderUtil;
+
 import org.hibernate.cache.Cache;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.CacheProvider;
 import org.hibernate.cache.Timestamper;
-
-import java.net.URL;
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Cache Provider plugin for Hibernate 3.2 and ehcache-1.2. New in this provider are ehcache support for multiple
@@ -63,7 +64,7 @@
      */
     public static final String NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME = "net.sf.ehcache.configurationResourceName";
 
-    private static final Logger LOG = Logger.getLogger(EhCacheProvider.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(EhCacheProvider.class);
 
     private CacheManager manager;
 
@@ -86,10 +87,10 @@
         try {
             net.sf.ehcache.Ehcache cache = manager.getEhcache(name);
             if (cache == null) {
-                LOG.log(Level.WARNING, "Could not find a specific ehcache configuration for cache named [" + name + "]; using defaults.");
+                LOG.warn("Could not find a specific ehcache configuration for cache named [{}]; using defaults.", name);
                 manager.addCache(name);
                 cache = manager.getEhcache(name);
-                EhCacheProvider.LOG.log(Level.FINE, "started EHCache region: " + name);
+                EhCacheProvider.LOG.debug("started EHCache region: {}", name);
             }
             return new net.sf.ehcache.hibernate.EhCache(cache);
         } catch (net.sf.ehcache.CacheException e) {
@@ -113,7 +114,7 @@
      */
     public final void start(Properties properties) throws CacheException {
         if (manager != null) {
-            LOG.log(Level.WARNING, "Attempt to restart an already started EhCacheProvider. Use sessionFactory.close() " +
+            LOG.warn("Attempt to restart an already started EhCacheProvider. Use sessionFactory.close() " +
                     " between repeated calls to buildSessionFactory. Using previously created EhCacheProvider." +
                     " If this behaviour is required, consider using SingletonEhCacheProvider.");
             return;
@@ -151,16 +152,12 @@
         if (url == null) {
             url = this.getClass().getResource(configurationResourceName);
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Creating EhCacheProvider from a specified resource: "
-                    + configurationResourceName + " Resolved to URL: " + url);
-        }
+        LOG.debug("Creating EhCacheProvider from a specified resource: {} Resolved to URL: {}",
+                configurationResourceName, url);
         if (url == null) {
-            if (LOG.isLoggable(Level.WARNING)) {
-                LOG.log(Level.WARNING, "A configurationResourceName was set to " + configurationResourceName +
-                        " but the resource could not be loaded from the classpath." +
-                        "Ehcache will configure itself using defaults.");
-            }
+            LOG.warn("A configurationResourceName was set to {} but the resource could not be" +
+                    " loaded from the classpath. Ehcache will configure itself using defaults.",
+                    configurationResourceName);
         }
         return url;
     }
Index: src/main/java/net/sf/ehcache/management/CacheManager.java
===================================================================
--- src/main/java/net/sf/ehcache/management/CacheManager.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/management/CacheManager.java	(working copy)
@@ -16,12 +16,13 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.CacheException;
+import java.util.ArrayList;
+import java.util.List;
 
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
-import java.util.ArrayList;
-import java.util.List;
+
+import net.sf.ehcache.CacheException;
 
 /**
  * An MBean implementation for those attributes and operations we wish to expose on net.sf.ehcache.CacheManager.
Index: src/main/java/net/sf/ehcache/management/CacheStatistics.java
===================================================================
--- src/main/java/net/sf/ehcache/management/CacheStatistics.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/management/CacheStatistics.java	(working copy)
@@ -16,14 +16,15 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Statistics;
+import java.io.Serializable;
 
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
-import java.io.Serializable;
 
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Statistics;
+
 
 /**
  * A JMX CacheStatistics decorator for an ehcache Statistics class.
Index: src/main/java/net/sf/ehcache/management/CacheConfiguration.java
===================================================================
--- src/main/java/net/sf/ehcache/management/CacheConfiguration.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/management/CacheConfiguration.java	(working copy)
@@ -16,12 +16,13 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.CacheException;
+import java.io.Serializable;
 
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
-import java.io.Serializable;
 
+import net.sf.ehcache.CacheException;
+
 
 /**
  * A JMX MBean implementation and decorator to net.sf.ehcache.CacheConfiguration
Index: src/main/java/net/sf/ehcache/management/Cache.java
===================================================================
--- src/main/java/net/sf/ehcache/management/Cache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/management/Cache.java	(working copy)
@@ -16,12 +16,13 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
+import java.io.Serializable;
 
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
-import java.io.Serializable;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
 
 /**
  * A JMX MBean implementation for Cache
Index: src/main/java/net/sf/ehcache/management/ManagementService.java
===================================================================
--- src/main/java/net/sf/ehcache/management/ManagementService.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/management/ManagementService.java	(working copy)
@@ -16,9 +16,9 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Status;
-import net.sf.ehcache.event.CacheManagerEventListener;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
 
 import javax.management.InstanceAlreadyExistsException;
 import javax.management.MBeanRegistrationException;
@@ -26,11 +26,13 @@
 import javax.management.MalformedObjectNameException;
 import javax.management.NotCompliantMBeanException;
 import javax.management.ObjectName;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Status;
+import net.sf.ehcache.event.CacheManagerEventListener;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Ehcache CacheManagers and Caches have lifecycles. Often normal use of a CacheManager
@@ -56,7 +58,7 @@
  */
 public class ManagementService implements CacheManagerEventListener {
 
-    private static final Logger LOG = Logger.getLogger(ManagementService.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ManagementService.class.getName());
 
     private MBeanServer mBeanServer;
     private net.sf.ehcache.CacheManager backingCacheManager;
@@ -224,14 +226,14 @@
                     + backingCacheManager.toString()), null));
         } catch (MalformedObjectNameException e) {
             //this should not happen
-            LOG.log(Level.SEVERE, "Error querying MBeanServer. Error was " + e.getMessage(), e);
+            LOG.error("Error querying MBeanServer. Error was " + e.getMessage(), e);
         }
         for (Iterator iterator = registeredObjectNames.iterator(); iterator.hasNext();) {
             ObjectName objectName = (ObjectName) iterator.next();
             try {
                 mBeanServer.unregisterMBean(objectName);
             } catch (Exception e) {
-                LOG.log(Level.SEVERE, "Error unregistering object instance " + objectName
+                LOG.error("Error unregistering object instance " + objectName
                         + " . Error was " + e.getMessage(), e);
             }
         }
@@ -268,7 +270,7 @@
                 registerCacheStatisticsIfRequired(cache);
                 registerCacheConfigurationIfRequired(cache);
             } catch (Exception e) {
-                LOG.log(Level.SEVERE, "Error registering cache for management for " + cache.getObjectName()
+                LOG.error("Error registering cache for management for " + cache.getObjectName()
                         + " . Error was " + e.getMessage(), e);
             }
         }
@@ -303,7 +305,7 @@
                 mBeanServer.unregisterMBean(objectName);
             }
         } catch (Exception e) {
-            LOG.log(Level.SEVERE, "Error unregistering cache for management for " + objectName
+            LOG.error("Error unregistering cache for management for " + objectName
                     + " . Error was " + e.getMessage(), e);
         }
 
Index: src/main/java/net/sf/ehcache/util/PropertyUtil.java
===================================================================
--- src/main/java/net/sf/ehcache/util/PropertyUtil.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/util/PropertyUtil.java	(working copy)
@@ -21,8 +21,9 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Property utilities.
@@ -31,7 +32,7 @@
  */
 public final class PropertyUtil {
 
-    private static final Logger LOG = Logger.getLogger(PropertyUtil.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(PropertyUtil.class);
 
     private static final String DEFAULT_PROPERTY_SEPARATOR = ",";
 
@@ -53,10 +54,7 @@
         if (foundValue != null) {
             foundValue = foundValue.trim();
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, new StringBuffer().append("Value found for ").append(name).append(": ")
-                    .append(foundValue).toString());
-        }
+        LOG.debug("Value found for {}:{}", name, foundValue);
         return foundValue;
     }
 
@@ -71,10 +69,7 @@
         if (foundValue != null) {
             foundValue = foundValue.trim();
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, new StringBuffer().append("Value found for ").append(name).append(": ")
-                    .append(foundValue).toString());
-        }
+        LOG.debug("Value found for {}:{}", name, foundValue);
         return foundValue;
     }
 
@@ -86,7 +81,7 @@
     public static Properties parseProperties(String propertiesString, String propertySeparator) {
         String propertySeparatorLocal = propertySeparator;
         if (propertiesString == null) {
-            LOG.log(Level.FINE, "propertiesString is null.");
+            LOG.debug("propertiesString is null.");
             return null;
         }
         if (propertySeparator == null) {
@@ -98,7 +93,7 @@
         try {
             properties.load(new ByteArrayInputStream(propertyLines.getBytes()));
         } catch (IOException e) {
-            LOG.log(Level.SEVERE, "Cannot load properties from " + propertiesString);
+            LOG.error("Cannot load properties from {}", propertiesString);
         }
         return properties;
     }
Index: src/main/java/net/sf/ehcache/constructs/blocking/BlockingCache.java
===================================================================
--- src/main/java/net/sf/ehcache/constructs/blocking/BlockingCache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/constructs/blocking/BlockingCache.java	(working copy)
@@ -16,6 +16,11 @@
 
 package net.sf.ehcache.constructs.blocking;
 
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Ehcache;
@@ -31,11 +36,6 @@
 import net.sf.ehcache.extension.CacheExtension;
 import net.sf.ehcache.loader.CacheLoader;
 
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
 
 /**
  * A blocking decorator for an Ehcache, backed by a {@link Ehcache}.
Index: src/main/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCache.java
===================================================================
--- src/main/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCache.java	(working copy)
@@ -16,14 +16,15 @@
 
 package net.sf.ehcache.constructs.blocking;
 
+import java.util.Collection;
+import java.util.Iterator;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -43,7 +44,7 @@
  */
 public class SelfPopulatingCache extends BlockingCache {
 
-    private static final Logger LOG = Logger.getLogger(SelfPopulatingCache.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(SelfPopulatingCache.class);
 
     /**
      * A factory for creating entries, given a key
@@ -135,8 +136,8 @@
         // Refetch the entries
         final Collection keys = getKeys();
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine(getName() + ": found " + keys.size() + " keys to refresh");
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("{}: found {} keys to refresh", getName(), keys.size());
         }
 
         // perform the refresh
@@ -148,9 +149,7 @@
                 final Element element = backingCache.getQuiet(key);
 
                 if (element == null) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.fine(getName() + ": entry with key " + key + " has been removed - skipping it");
-                    }
+                    LOG.debug("{}: entry with key {} has been removed - skipping it", getName(), key);
 
                     continue;
                 }
@@ -160,7 +159,7 @@
                 // Collect the exception and keep going.
                 // Throw the exception once all the entries have been refreshed
                 // If the refresh fails, keep the old element. It will simply become staler.
-                LOG.log(Level.WARNING, getName() + "Could not refresh element " + key, e);
+                LOG.warn(getName() + "Could not refresh element " + key, e);
                 exception = e;
             }
         }
@@ -252,9 +251,7 @@
             throws Exception {
         Object key = element.getObjectKey();
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine(getName() + ": refreshing element with key " + key);
-        }
+        LOG.debug("{}: refreshing element with key {}", getName(), key);
 
         final Element replacementElement;
 
Index: src/main/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCache.java
===================================================================
--- src/main/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCache.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCache.java	(working copy)
@@ -22,8 +22,9 @@
 import net.sf.ehcache.Element;
 import net.sf.ehcache.concurrent.Mutex;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 
 /**
@@ -41,7 +42,7 @@
  */
 public class UpdatingSelfPopulatingCache extends SelfPopulatingCache {
 
-    private static final Logger LOG = Logger.getLogger(UpdatingSelfPopulatingCache.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(UpdatingSelfPopulatingCache.class);
 
     /**
      * Creates a SelfPopulatingCache.
@@ -101,8 +102,8 @@
             final Element element = backingCache.getQuiet(key);
 
             if (element == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.fine(getName() + ": entry with key " + key + " has been removed - skipping it");
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("{}: entry with key {} has been removed - skipping it", getName(), key);
                 }
                 return;
             }
@@ -112,7 +113,7 @@
             // Collect the exception and keep going.
             // Throw the exception once all the entries have been refreshed
             // If the refresh fails, keep the old element. It will simply become staler.
-            LOG.log(Level.WARNING, getName() + "Could not refresh element " + key, e);
+            LOG.warn(getName() + "Could not refresh element " + key, e);
         }
     }
 
Index: src/main/java/net/sf/ehcache/store/DiskStore.java
===================================================================
--- src/main/java/net/sf/ehcache/store/DiskStore.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/DiskStore.java	(working copy)
@@ -17,14 +17,6 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.Status;
-import net.sf.ehcache.config.CacheConfiguration;
-import net.sf.ehcache.event.RegisteredEventListeners;
-import net.sf.ehcache.util.MemoryEfficientByteArrayOutputStream;
-
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;
@@ -38,16 +30,25 @@
 import java.io.StreamCorruptedException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.ConcurrentModificationException;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.Status;
+import net.sf.ehcache.config.CacheConfiguration;
+import net.sf.ehcache.event.RegisteredEventListeners;
+import net.sf.ehcache.util.MemoryEfficientByteArrayOutputStream;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A disk store implementation.
@@ -74,7 +75,7 @@
      */
     public static final String AUTO_DISK_PATH_DIRECTORY_PREFIX = "ehcache_auto_created";
 
-    private static final Logger LOG = Logger.getLogger(DiskStore.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(DiskStore.class);
     private static final int MS_PER_SECOND = 1000;
     private static final int SPOOL_THREAD_INTERVAL = 200;
     private static final int ESTIMATED_MINIMUM_PAYLOAD_SIZE = 512;
@@ -197,21 +198,17 @@
         if (persistent) {
             //if diskpath contains auto generated string
             if (diskPath.indexOf(AUTO_DISK_PATH_DIRECTORY_PREFIX) != -1) {
-                LOG.log(Level.WARNING, "Data in persistent disk stores is ignored for stores from automatically created directories"
-                        + " (they start with " + AUTO_DISK_PATH_DIRECTORY_PREFIX + ").\n"
+                LOG.warn("Data in persistent disk stores is ignored for stores from automatically created directories"
+                        + " (they start with {}).\n"
                         + "Remove diskPersistent or resolve the conflicting disk paths in cache configuration.\n"
-                        + "Deleting data file " + getDataFileName());
+                        + "Deleting data file {}", AUTO_DISK_PATH_DIRECTORY_PREFIX, getDataFileName());
                 dataFile.delete();
             } else if (!readIndex()) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Index file dirty or empty. Deleting data file " + getDataFileName());
-                }
+                LOG.debug("Index file dirty or empty. Deleting data file {}", getDataFileName());
                 dataFile.delete();
             }
         } else {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Deleting data file " + getDataFileName());
-            }
+            LOG.debug("Deleting data file {}", getDataFileName());
             dataFile.delete();
             indexFile = null;
         }
@@ -224,9 +221,7 @@
         boolean dataFileExists = dataFile.exists();
         boolean indexFileExists = indexFile.exists();
         if (!dataFileExists && indexFileExists) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Matching data file missing for index file. Deleting index file " + getIndexFileName());
-            }
+            LOG.debug("Matching data file missing for index file. Deleting index file {}", getIndexFileName());
             indexFile.delete();
         }
     }
@@ -270,7 +265,7 @@
             }
             return element;
         } catch (Exception exception) {
-            LOG.log(Level.SEVERE, name + "Cache: Could not read disk store element for key " + key + ". Error was "
+            LOG.error(name + "Cache: Could not read disk store element for key " + key + ". Error was "
                     + exception.getMessage(), exception);
         }
         return null;
@@ -347,7 +342,7 @@
             //element.updateAccessStatistics(); Don't update statistics
             return element;
         } catch (Exception e) {
-            LOG.log(Level.SEVERE, name + "Cache: Could not read disk store element for key " + key
+            LOG.error(name + "Cache: Could not read disk store element for key " + key
                     + ". Initial cause was " + e.getMessage(), e);
         }
         return null;
@@ -383,7 +378,7 @@
             int diskSize = diskElements.size();
             return spoolSize + diskSize;
         } catch (Exception e) {
-            LOG.log(Level.SEVERE, name + "Cache: Could not determine size of disk store.. Initial cause was " + e.getMessage(), e);
+            LOG.error(name + "Cache: Could not determine size of disk store.. Initial cause was " + e.getMessage(), e);
             return 0;
         }
     }
@@ -423,13 +418,13 @@
             if (spoolAndExpiryThread.isAlive()) {
                 spool.put(element.getObjectKey(), element);
             } else {
-                LOG.log(Level.SEVERE, name + "Cache: Elements cannot be written to disk store because the" +
-                        " spool thread has died.");
+                LOG.error("{}Cache: Elements cannot be written to disk store because the" +
+                        " spool thread has died.", name);
                 spool.clear();
             }
 
         } catch (Exception e) {
-            LOG.log(Level.SEVERE, name + "Cache: Could not write disk store element for " + element.getObjectKey()
+            LOG.error(name + "Cache: Could not write disk store element for " + element.getObjectKey()
                     + ". Initial cause was " + e.getMessage(), e);
         }
     }
@@ -445,8 +440,8 @@
     public boolean bufferFull() {
         long estimatedSpoolSize = spool.size() * lastElementSize;
         boolean backedUp = estimatedSpoolSize > diskSpoolBufferSizeBytes;
-        if (backedUp && LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "A back up on disk store puts occurred. Consider increasing diskSpoolBufferSizeMB for cache " + name);
+        if (backedUp) {
+            LOG.debug("A back up on disk store puts occurred. Consider increasing diskSpoolBufferSizeMB for cache {}", name);
         }
         return backedUp;
 
@@ -472,7 +467,7 @@
         } catch (Exception exception) {
             String message = name + "Cache: Could not remove disk store entry for key " + key
                     + ". Error was " + exception.getMessage();
-            LOG.log(Level.SEVERE, message, exception);
+            LOG.error(message, exception);
             throw new CacheException(message);
         }
         return element;
@@ -519,7 +514,7 @@
             }
         } catch (Exception e) {
             // Clean up
-            LOG.log(Level.SEVERE, name + " Cache: Could not rebuild disk store. Initial cause was " + e.getMessage(), e);
+            LOG.error(name + " Cache: Could not rebuild disk store. Initial cause was " + e.getMessage(), e);
             dispose();
         }
     }
@@ -565,11 +560,11 @@
             }
             deleteFilesInAutoGeneratedDirectory();
             if (!persistent) {
-                LOG.log(Level.FINE, "Deleting file " + dataFile.getName());
+                LOG.debug("Deleting file {}", dataFile.getName());
                 dataFile.delete();
             }
         } catch (Exception e) {
-            LOG.log(Level.SEVERE, name + "Cache: Could not shut down disk cache. Initial cause was " + e.getMessage(), e);
+            LOG.error(name + "Cache: Could not shut down disk cache. Initial cause was " + e.getMessage(), e);
         } finally {
             active = false;
             randomAccessFile = null;
@@ -586,11 +581,11 @@
     protected void deleteFilesInAutoGeneratedDirectory() {
         if (diskPath.indexOf(AUTO_DISK_PATH_DIRECTORY_PREFIX) != -1) {
             if (dataFile != null && dataFile.exists()) {
-                LOG.log(Level.FINE, "Deleting file " + dataFile.getName());
+                LOG.debug("Deleting file {}", dataFile.getName());
                 dataFile.delete();
             }
             if (indexFile != null && indexFile.exists()) {
-                LOG.log(Level.FINE, "Deleting file " + indexFile.getName());
+                LOG.debug("Deleting file {}", indexFile.getName());
                 indexFile.delete();
             }
             //try to delete the auto_createtimestamp directory. Will work when the last Disk Store deletes
@@ -598,7 +593,7 @@
             File dataDirectory = new File(diskPath);
             if (dataDirectory != null && dataDirectory.exists()) {
                 if (dataDirectory.delete()) {
-                    LOG.log(Level.FINE, "Deleted directory " + dataDirectory.getName());
+                    LOG.debug("Deleted directory {}", dataDirectory.getName());
                 }
             }
 
@@ -658,7 +653,7 @@
                 updatedNextExpiryTime += expiryThreadInterval * MS_PER_SECOND;
                 expireElements();
             } catch (Throwable e) {
-                LOG.log(Level.SEVERE, name + " Cache: Could not expire elements from disk due to "
+                LOG.error(name + " Cache: Could not expire elements from disk due to "
                         + e.getMessage() + ". Continuing...", e);
             }
         }
@@ -681,7 +676,7 @@
 
                     }
                 } catch (Throwable e) {
-                    LOG.log(Level.SEVERE, name + " Cache: Could not flush elements to disk due to "
+                    LOG.error(name + " Cache: Could not flush elements to disk due to "
                             + e.getMessage() + ". Continuing...", e);
                 }
             }
@@ -759,13 +754,13 @@
                 lastElementSize = bufferLength;
                 diskElements.put(key, diskElement);
             } catch (OutOfMemoryError e) {
-                LOG.log(Level.SEVERE, "OutOfMemoryError on serialize: " + key);
+                LOG.error("OutOfMemoryError on serialize: " + key);
 
             }
 
         } catch (Exception e) {
             // Catch any exception that occurs during serialization
-            LOG.log(Level.SEVERE, name + "Cache: Failed to write element to disk '" + key
+            LOG.error(name + "Cache: Failed to write element to disk '" + key
                     + "'. Initial cause was " + e.getMessage(), e);
         }
 
@@ -788,8 +783,8 @@
                 Thread.sleep(QUARTER_OF_A_SECOND);
             }
         }
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Gave up trying to Serialize " + element.getObjectKey(), exception);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Gave up trying to Serialize " + element.getObjectKey(), exception);
         }
         return null;
     }
@@ -886,14 +881,12 @@
                 freeSpace = (List) objectInputStream.readObject();
                 success = true;
             } catch (StreamCorruptedException e) {
-                LOG.log(Level.SEVERE, "Corrupt index file. Creating new index.");
+                LOG.error("Corrupt index file. Creating new index.");
             } catch (IOException e) {
                 //normal when creating the cache for the first time
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "IOException reading index. Creating new index. ");
-                }
+                LOG.debug("IOException reading index. Creating new index. ");
             } catch (ClassNotFoundException e) {
-                LOG.log(Level.SEVERE, "Class loading problem reading index. Creating new index. Initial cause was " + e.getMessage(), e);
+                LOG.error("Class loading problem reading index. Creating new index. Initial cause was " + e.getMessage(), e);
             } finally {
                 try {
                     if (objectInputStream != null) {
@@ -903,7 +896,7 @@
                         fin.close();
                     }
                 } catch (IOException e) {
-                    LOG.log(Level.SEVERE, "Problem closing the index file.");
+                    LOG.error("Problem closing the index file.");
                 }
 
                 if (!success) {
@@ -922,17 +915,13 @@
     private void createNewIndexFile() throws IOException {
         if (indexFile.exists()) {
             if (indexFile.delete()) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Index file " + indexFile + " deleted.");
-                }
+                LOG.debug("Index file {} deleted.", indexFile);
             } else {
                 throw new IOException("Index file " + indexFile + " could not deleted.");
             }
         }
         if (indexFile.createNewFile()) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Index file " + indexFile + " created successfully");
-            }
+            LOG.debug("Index file {} created successfully", indexFile);
         } else {
             throw new IOException("Index file " + indexFile + " could not created.");
         }
@@ -952,8 +941,8 @@
             final Element element = (Element) iterator.next();
             if (element.isExpired()) {
                 // An expired element
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, name + "Cache: Removing expired spool element " + element.getObjectKey());
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(name + "Cache: Removing expired spool element {}", element.getObjectKey());
                 }
                 iterator.remove();
                 notifyExpiryListeners(element);
@@ -969,8 +958,8 @@
 
             if (now >= diskElement.expiryTime) {
                 // An expired element
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, name + "Cache: Removing expired spool element " + entry.getKey() + " from Disk Store");
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("{} Cache: Removing expired spool element {} from Disk Store", name, entry.getKey());
                 }
 
                 iterator.remove();
@@ -981,7 +970,7 @@
                         element = loadElementFromDiskElement(diskElement);
                         notifyExpiryListeners(element);
                     } catch (Exception exception) {
-                        LOG.log(Level.SEVERE, name + "Cache: Could not remove disk store entry for " + entry.getKey()
+                        LOG.error(name + "Cache: Could not remove disk store entry for " + entry.getKey()
                                 + ". Error was " + exception.getMessage(), exception);
                     }
                 }
@@ -1280,7 +1269,7 @@
                 element = loadElementFromDiskElement(diskElement);
                 cache.getCacheEventNotificationService().notifyElementEvicted(element, false);
             } catch (Exception exception) {
-                LOG.log(Level.SEVERE, name + "Cache: Could not notify disk store eviction of " + element.getObjectKey() +
+                LOG.error(name + "Cache: Could not notify disk store eviction of " + element.getObjectKey() +
                         ". Error was " + exception.getMessage(), exception);
             }
         }
Index: src/main/java/net/sf/ehcache/store/MemoryStore.java
===================================================================
--- src/main/java/net/sf/ehcache/store/MemoryStore.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/MemoryStore.java	(working copy)
@@ -16,19 +16,20 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.Status;
-
 import java.util.Iterator;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.Status;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A Store implementation suitable for fast, concurrent in memory stores. The policy is determined by that
@@ -59,7 +60,7 @@
 
     private static final int JUMP_AHEAD = 5;
 
-    private static final Logger LOG = Logger.getLogger(MemoryStore.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(MemoryStore.class);
 
     /**
      * The eviction policy to use
@@ -121,8 +122,8 @@
 
         status = Status.STATUS_ALIVE;
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Initialized " + this.getClass().getName() + " for " + cache.getName());
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Initialized {} for {}", this.getClass().getName(), cache.getName());
         }
     }
 
@@ -169,11 +170,11 @@
 
         if (element != null) {
             element.updateAccessStatistics();
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.fine(cache.getName() + "Cache: " + cache.getName() + "MemoryStore hit for " + key);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("{}Cache: {}MemoryStore hit for {}", new Object[]{cache.getName(), cache.getName(), key});
             }
-        } else if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine(cache.getName() + "Cache: " + cache.getName() + "MemoryStore miss for " + key);
+        } else if (LOG.isDebugEnabled()) {
+            LOG.debug("{}Cache: {}MemoryStore miss for {}", new Object[]{cache.getName(), cache.getName(), key});
         }
 
         return element;
@@ -191,11 +192,11 @@
 
         if (cacheElement != null) {
             //cacheElement.updateAccessStatistics(); Don't update statistics
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.fine(cache.getName() + "Cache: " + cache.getName() + "MemoryStore hit for " + key);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("{}Cache: {}MemoryStore hit for {}", new Object[]{cache.getName(), cache.getName(), key});
             }
-        } else if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine(cache.getName() + "Cache: " + cache.getName() + "MemoryStore miss for " + key);
+        } else if (LOG.isDebugEnabled()) {
+            LOG.debug("{}Cache: {}MemoryStore miss for {}", new Object[]{cache.getName(), cache.getName(), key});
         }
         return cacheElement;
     }
@@ -218,9 +219,7 @@
         if (element != null) {
             return element;
         } else {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, cache.getName() + "Cache: Cannot remove entry as key " + key + " was not found");
-            }
+            LOG.debug("{}Cache: Cannot remove entry as key {} was not found", cache.getName(), key);
             return null;
         }
     }
@@ -269,8 +268,8 @@
      */
     public final void flush() {
         if (cache.getCacheConfiguration().isDiskPersistent()) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, cache.getName() + " is persistent. Spooling " + map.size() + " elements to the disk store.");
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("{} is persistent. Spooling {} elements to the disk store.", cache.getName(), map.size());
             }
             spoolAllToDisk();
         }
@@ -293,9 +292,9 @@
             Element element = (Element) map.get(keys[i]);
             if (element != null) {
                 if (!element.isSerializable()) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Object with key " + element.getObjectKey()
-                                + " is not Serializable and is not being overflowed to disk.");
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Object with key {} is not Serializable and is not being overflowed to" +
+                                " disk.", element.getObjectKey());
                     }
                 } else {
                     spoolToDisk(element);
@@ -319,8 +318,8 @@
      */
     protected void spoolToDisk(Element element) {
         diskStore.put(element);
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, cache.getName() + "Cache: spool to disk done for: " + element.getObjectKey());
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("{}Cache: spool to disk done for: {}", cache.getName(), element.getObjectKey());
         }
     }
 
@@ -401,9 +400,8 @@
         boolean spooled = false;
         if (cache.getCacheConfiguration().isOverflowToDisk()) {
             if (!element.isSerializable()) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, new StringBuffer("Object with key ").append(element.getObjectKey())
-                            .append(" is not Serializable and cannot be overflowed to disk").toString());
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Object with key {} is not Serializable and cannot be overflowed to disk", element.getObjectKey());
                 }
             } else {
                 spoolToDisk(element);
@@ -528,13 +526,11 @@
      */
     protected void removeElementChosenByEvictionPolicy(Element elementJustAdded) {
 
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine("Cache is full. Removing element ...");
-        }
+        LOG.debug("Cache is full. Removing element ...");
 
         Element element = findEvictionCandidate(elementJustAdded);
         if (element == null) {
-            LOG.log(Level.FINE, "Eviction selection miss. Selected element is null");
+            LOG.debug("Eviction selection miss. Selected element is null");
             return;
         }
 
Index: src/main/java/net/sf/ehcache/store/MemoryStoreEvictionPolicy.java
===================================================================
--- src/main/java/net/sf/ehcache/store/MemoryStoreEvictionPolicy.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/MemoryStoreEvictionPolicy.java	(working copy)
@@ -18,8 +18,9 @@
 
 
 import java.io.Serializable;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A typesafe enumeration of eviction policies.
@@ -54,7 +55,7 @@
      */
     public static final MemoryStoreEvictionPolicy FIFO = new MemoryStoreEvictionPolicy("FIFO");
 
-    private static final Logger LOG = Logger.getLogger(MemoryStoreEvictionPolicy.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(MemoryStoreEvictionPolicy.class);
 
     private final String myName;
 
@@ -90,10 +91,8 @@
             }
         }
 
-        if (LOG.isLoggable(Level.WARNING)) {
-            LOG.log(Level.WARNING, "The memoryStoreEvictionPolicy of " + policy + " cannot be resolved. The policy will be" +
-                    " set to LRU");
-        }
+        LOG.warn("The memoryStoreEvictionPolicy of {} cannot be resolved. The policy will be" +
+                " set to LRU", policy);
         return LRU;
     }
 }
Index: src/main/java/net/sf/ehcache/store/LruMemoryStore.java
===================================================================
--- src/main/java/net/sf/ehcache/store/LruMemoryStore.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/LruMemoryStore.java	(working copy)
@@ -16,15 +16,16 @@
 
 package net.sf.ehcache.store;
 
+import java.util.Iterator;
+import java.util.Map;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.Status;
 
-import java.util.Iterator;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -38,7 +39,7 @@
  */
 public class LruMemoryStore implements Store {
 
-    private static final Logger LOG = Logger.getLogger(LruMemoryStore.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(LruMemoryStore.class);
 
     /**
      * The cache this store is associated with.
@@ -186,8 +187,8 @@
      */
     public final void flush() {
         if (cache.getCacheConfiguration().isDiskPersistent()) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, cache.getName() + " is persistent. Spooling " + map.size() + " elements to the disk store.");
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("{} is persistent. Spooling {} elements to the disk store.", cache.getName(), map.size());
             }
             spoolAllToDisk();
         }
@@ -211,9 +212,8 @@
             Element element = (Element) map.get(key);
             if (element != null) {
                 if (!element.isSerializable()) {
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, "Object with key " + element.getObjectKey()
-                                + " is not Serializable and is not being overflowed to disk.");
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Object with key {} is not Serializable and is not being overflowed to disk.", element.getObjectKey());
                     }
                 } else {
                     spoolToDisk(element);
@@ -237,8 +237,8 @@
      */
     protected void spoolToDisk(Element element) {
         diskStore.put(element);
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, cache.getName() + "Cache: spool to disk done for: " + element.getObjectKey());
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("{}Cache: spool to disk done for: {}", cache.getName(), element.getObjectKey());
         }
     }
 
@@ -319,9 +319,9 @@
         boolean spooled = false;
         if (cache.getCacheConfiguration().isOverflowToDisk()) {
             if (!element.isSerializable()) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, new StringBuffer("Object with key ").append(element.getObjectKey())
-                            .append(" is not Serializable and cannot be overflowed to disk").toString());
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Object with key {} is not Serializable and cannot be overflowed" +
+                            " to disk", element.getObjectKey());
                 }
             } else {
                 spoolToDisk(element);
Index: src/main/java/net/sf/ehcache/store/AbstractPolicy.java
===================================================================
--- src/main/java/net/sf/ehcache/store/AbstractPolicy.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/AbstractPolicy.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.Element;
-
 import java.util.Random;
 
+import net.sf.ehcache.Element;
+
 /**
  * A base policy class
  *
Index: src/main/java/net/sf/ehcache/store/Store.java
===================================================================
--- src/main/java/net/sf/ehcache/store/Store.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/store/Store.java	(working copy)
@@ -16,12 +16,12 @@
 
 package net.sf.ehcache.store;
 
+import java.io.IOException;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.Status;
 
-import java.io.IOException;
-
 /**
  * This is the interface for all stores. A store is a physical counterpart to a cache, which
  * is a logical concept.
Index: src/main/java/net/sf/ehcache/CacheManager.java
===================================================================
--- src/main/java/net/sf/ehcache/CacheManager.java	(revision 1022)
+++ src/main/java/net/sf/ehcache/CacheManager.java	(working copy)
@@ -17,6 +17,17 @@
 
 package net.sf.ehcache;
 
+import java.io.File;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 import net.sf.ehcache.config.Configuration;
 import net.sf.ehcache.config.ConfigurationFactory;
 import net.sf.ehcache.config.ConfigurationHelper;
@@ -28,18 +39,8 @@
 import net.sf.ehcache.store.DiskStore;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.io.File;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A container for {@link Ehcache}s that maintain all aspects of their lifecycle.
@@ -66,7 +67,7 @@
      */
     public static final String ENABLE_SHUTDOWN_HOOK_PROPERTY = "net.sf.ehcache.enableShutdownHook";
 
-    private static final Logger LOG = Logger.getLogger(CacheManager.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(CacheManager.class);
 
     /**
      * The Singleton Instance.
@@ -267,9 +268,7 @@
         Configuration configuration;
         String configurationSource;
         if (configurationFileName != null) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Configuring CacheManager from " + configurationFileName);
-            }
+            LOG.debug("Configuring CacheManager from {}", configurationFileName);
             configuration = ConfigurationFactory.parseConfiguration(new File(configurationFileName));
             configurationSource = "file located at " + configurationFileName;
         } else if (configurationURL != null) {
@@ -279,9 +278,7 @@
             configuration = ConfigurationFactory.parseConfiguration(configurationInputStream);
             configurationSource = "InputStream " + configurationInputStream;
         } else {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "Configuring ehcache from classpath.");
-            }
+            LOG.debug("Configuring ehcache from classpath.");
             configuration = ConfigurationFactory.parseConfiguration();
             configurationSource = "classpath";
         }
@@ -298,9 +295,9 @@
 
         if (diskStorePath == null && cachesRequiringDiskStores > 0) {
             diskStorePath = DiskStoreConfiguration.getDefaultPath();
-            LOG.log(Level.WARNING, "One or more caches require a DiskStore but there is no diskStore element configured." +
-                    " Using the default disk store path of " + DiskStoreConfiguration.getDefaultPath() +
-                    ". Please explicitly configure the diskStore element in ehcache.xml.");
+            LOG.warn("One or more caches require a DiskStore but there is no diskStore element configured." +
+                    " Using the default disk store path of {}. Please explicitly configure the diskStore" +
+                    " element in ehcache.xml.", DiskStoreConfiguration.getDefaultPath());
         }
 
         detectAndFixDiskStorePathConflict(configurationHelper);
@@ -324,22 +321,22 @@
 
     private void detectAndFixDiskStorePathConflict(ConfigurationHelper configurationHelper) {
         if (diskStorePath == null) {
-            if (LOG.isLoggable(Level.FINE)) {
-                LOG.log(Level.FINE, "No disk store path defined. Skipping disk store path conflict test.");
-            }
+            LOG.debug("No disk store path defined. Skipping disk store path conflict test.");
             return;
         }
 
         for (CacheManager cacheManager : ALL_CACHE_MANAGERS) {
             if (diskStorePath.equals(cacheManager.diskStorePath)) {
                 String newDiskStorePath = diskStorePath + File.separator + DiskStore.generateUniqueDirectory();
-                LOG.log(Level.WARNING, "Creating a new instance of CacheManager using the diskStorePath \""
-                        + diskStorePath + "\" which is already used" +
+                LOG.warn("Creating a new instance of CacheManager using the diskStorePath \""
+                        + "{}\" which is already used" +
                         " by an existing CacheManager.\nThe source of the configuration was "
-                        + configurationHelper.getConfigurationBean().getConfigurationSource() + ".\n" +
-                        "The diskStore path for this CacheManager will be set to " + newDiskStorePath + ".\nTo avoid this" +
+                        + "{}.\n" +
+                        "The diskStore path for this CacheManager will be set to {}.\nTo avoid this" +
                         " warning consider using the CacheManager factory methods to create a singleton CacheManager " +
-                        "or specifying a separate ehcache configuration (ehcache.xml) for each CacheManager instance.");
+                        "or specifying a separate ehcache configuration (ehcache.xml) for each CacheManager instance.",
+                        new Object[]{diskStorePath, configurationHelper.getConfigurationBean().getConfigurationSource(),
+                         newDiskStorePath, });
                 diskStorePath = newDiskStorePath;
                 break;
             }
@@ -360,14 +357,14 @@
                     }
                     String otherUniqueResourceIdentifier = otherCacheManagerPeerListener.getUniqueResourceIdentifier();
                     if (uniqueResourceIdentifier.equals(otherUniqueResourceIdentifier)) {
-                        LOG.log(Level.WARNING, "Creating a new instance of CacheManager with a CacheManagerPeerListener which " +
+                        LOG.warn("Creating a new instance of CacheManager with a CacheManagerPeerListener which " +
                                 "has a conflict on a resource that must be unique.\n" +
-                                "The resource is " + uniqueResourceIdentifier + ".\n" +
-                                "Attempting automatic resolution. The source of the configuration was "
-                                + configurationHelper.getConfigurationBean().getConfigurationSource() + ".\n"
-                                + "To avoid this warning consider using the CacheManager factory methods to create a " +
+                                "The resource is {}.\n" +
+                                "Attempting automatic resolution. The source of the configuration was {}.\n" +
+                                "To avoid this warning consider using the CacheManager factory methods to create a " +
                                 "singleton CacheManager " +
-                                "or specifying a separate ehcache configuration (ehcache.xml) for each CacheManager instance.");
+                                "or specifying a separate ehcache configuration (ehcache.xml) for each CacheManager instance.",
+                                uniqueResourceIdentifier, configurationHelper.getConfigurationBean().getConfigurationSource());
                         cacheManagerPeerListener.attemptResolutionOfUniqueResourceConflict();
                         break;
                     }
@@ -407,14 +404,10 @@
         }
         synchronized (CacheManager.class) {
             if (singleton == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Creating new CacheManager with default config");
-                }
+                LOG.debug("Creating new CacheManager with default config");
                 singleton = new CacheManager();
             } else {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Attempting to create an existing singleton. Existing singleton returned.");
-                }
+                LOG.debug("Attempting to create an existing singleton. Existing singleton returned.");
             }
             return singleton;
         }
@@ -448,9 +441,7 @@
         }
         synchronized (CacheManager.class) {
             if (singleton == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Creating new CacheManager with config file: " + configurationFileName);
-                }
+                LOG.debug("Creating new CacheManager with config file: {}", configurationFileName);
                 singleton = new CacheManager(configurationFileName);
             }
             return singleton;
@@ -483,9 +474,7 @@
         }
         synchronized (CacheManager.class) {
             if (singleton == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Creating new CacheManager with config URL: " + configurationFileURL);
-                }
+                LOG.debug("Creating new CacheManager with config URL: {}", configurationFileURL);
                 singleton = new CacheManager(configurationFileURL);
 
             }
@@ -511,9 +500,7 @@
         }
         synchronized (CacheManager.class) {
             if (singleton == null) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "Creating new CacheManager with InputStream");
-                }
+                LOG.debug("Creating new CacheManager with InputStream");
                 singleton = new CacheManager(inputStream);
             }
             return singleton;
@@ -559,7 +546,7 @@
         if (!enabled) {
             return;
         } else {
-            LOG.log(Level.INFO, "The CacheManager shutdown hook is enabled because " + ENABLE_SHUTDOWN_HOOK_PROPERTY + " is set to true.");
+            LOG.info("The CacheManager shutdown hook is enabled because {} is set to true.", ENABLE_SHUTDOWN_HOOK_PROPERTY);
 
             Thread localShutdownHook = new Thread() {
                 public void run() {
@@ -569,9 +556,7 @@
                             // removeShutdownHook to remove it during shutdown
                             shutdownHook = null;
 
-                            if (LOG.isLoggable(Level.INFO)) {
-                                LOG.log(Level.INFO, "VM shutting down with the CacheManager still active. Calling shutdown.");
-                            }
+                            LOG.info("VM shutting down with the CacheManager still active. Calling shutdown.");
                             shutdown();
                         }
                     }
@@ -596,10 +581,8 @@
                 //This will be thrown if the VM is shutting down. In this case
                 //we do not need to worry about leaving references to CacheManagers lying
                 //around and the call is ok to fail.
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "IllegalStateException due to attempt to remove a shutdown" +
-                            "hook while the VM is actually shutting down.", e);
-                }
+                LOG.debug("IllegalStateException due to attempt to remove a shutdown" +
+                        "hook while the VM is actually shutting down.", e);
             }
             shutdownHook = null;
         }
@@ -696,7 +679,7 @@
         try {
             cache.bootstrap();
         } catch (CacheException e) {
-            LOG.log(Level.WARNING, "Cache " + cache.getName() + "requested bootstrap but a CacheException occured. " + e.getMessage(), e);
+            LOG.warn("Cache " + cache.getName() + "requested bootstrap but a CacheException occured. " + e.getMessage(), e);
         }
         ehcaches.put(cache.getName(), cache);
         if (cache instanceof Cache) {
@@ -766,9 +749,7 @@
     public void shutdown() {
         synchronized (CacheManager.class) {
             if (status.equals(Status.STATUS_SHUTDOWN)) {
-                if (LOG.isLoggable(Level.FINE)) {
-                    LOG.log(Level.FINE, "CacheManager already shutdown");
-                }
+                LOG.debug("CacheManager already shutdown");
                 return;
             }
             for (CacheManagerPeerProvider cacheManagerPeerProvider : cacheManagerPeerProviders.values()) {
@@ -845,9 +826,7 @@
      */
     public void clearAll() throws CacheException {
         String[] cacheNames = getCacheNames();
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.log(Level.FINE, "Clearing all caches");
-        }
+        LOG.debug("Clearing all caches");
         for (int i = 0; i < cacheNames.length; i++) {
             String cacheName = cacheNames[i];
             Ehcache cache = getEhcache(cacheName);
Index: src/test/resources/commons-logging.properties
===================================================================
--- src/test/resources/commons-logging.properties	(revision 1022)
+++ src/test/resources/commons-logging.properties	(working copy)
@@ -1,3 +0,0 @@
-# Use this to force commons logging to use Jdk14Logger.
-# If it finds log4j in the classpath it will use that.
-# org.apache.commons.logging.Log=org.apache.commons.logging.impl.Jdk14Logger
\ No newline at end of file
Index: src/test/resources/simplelog.properties
===================================================================
--- src/test/resources/simplelog.properties	(revision 1022)
+++ src/test/resources/simplelog.properties	(working copy)
@@ -1,17 +0,0 @@
-# - Default logging detail level for all instances of SimpleLog. Must be one of ("trace", "debug", "info", "warn", "error", or "fatal"). If not specified, defaults to "info".
-org.apache.commons.logging.simplelog.defaultlog=fatal
-
-# Logging detail level for a SimpleLog instance named "xxxxx". Must be one of ("trace", "debug", "info", "warn", "error", or "fatal"). If not specified, the default logging detail level is used.
-#org.apache.commons.logging.simplelog.log.xxxxx
-
-# Set to true if you want the Log instance name to be included in output messages. Defaults to false.
-org.apache.commons.logging.simplelog.showlogname=true
-
-#Set to true if you want the last component of the name to be included in output messages. Defaults to true.
-org.apache.commons.logging.simplelog.showShortLogname=false
-
-# Set to true if you want the current date and time to be included in output messages. Default is false.
-#org.apache.commons.logging.simplelog.showdatetime
-
-# The date and time format to be used in the output messages. The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat. If the format is not specified or is invalid, the default format is used. The default format is yyyy/MM/dd HH:mm:ss:SSS zzz.
-#org.apache.commons.logging.simplelog.dateTimeFormat
Index: src/test/resources/log4j.properties
===================================================================
--- src/test/resources/log4j.properties	(revision 0)
+++ src/test/resources/log4j.properties	(revision 0)
@@ -0,0 +1,7 @@
+# sample log4j.properties file for use with MockCentral
+  log4j.rootLogger=warn, myConsole
+
+  # define a console appender
+  log4j.appender.myConsole=org.apache.log4j.ConsoleAppender
+  log4j.appender.myConsole.layout=org.apache.log4j.PatternLayout
+  log4j.appender.myConsole.layout.ConversionPattern=%5p [%t] (%F:%L) %m%n
\ No newline at end of file
Index: src/test/java/net/sf/ehcache/hibernate/HibernateAPIUsageTest.java
===================================================================
--- src/test/java/net/sf/ehcache/hibernate/HibernateAPIUsageTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/hibernate/HibernateAPIUsageTest.java	(working copy)
@@ -16,18 +16,10 @@
 
 package net.sf.ehcache.hibernate;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import org.hibernate.cfg.Environment;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -35,6 +27,16 @@
 import java.util.Properties;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+
+import org.hibernate.cfg.Environment;
+import org.junit.After;
+import org.junit.Test;
+
 
 /**
  * Tests for a Cache
Index: src/test/java/net/sf/ehcache/store/FifoMemoryStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/store/FifoMemoryStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/store/FifoMemoryStoreTest.java	(working copy)
@@ -16,17 +16,19 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.MemoryStoreTester;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.MemoryStoreTester;
+
+import org.junit.Before;
+import org.junit.Test;
+
 /**
  * Test class for FifoMemoryStore
  * <p/>
Index: src/test/java/net/sf/ehcache/store/LruMemoryStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/store/LruMemoryStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/store/LruMemoryStoreTest.java	(working copy)
@@ -16,16 +16,17 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.Element;
-import net.sf.ehcache.MemoryStoreTester;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import org.junit.Before;
-import org.junit.Test;
 
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.Element;
+import net.sf.ehcache.MemoryStoreTester;
+
+import org.junit.Before;
+import org.junit.Test;
+
 
 /**
  * Test cases for the LruMemoryStore.
@@ -197,7 +198,7 @@
                 store.put(element);
             }
             assertEquals(12000, store.getSize());
-            LOG.log(Level.INFO, "Store size is: " + store.getSize());
+            LOG.info("Store size is: " + store.getSize());
         }
     }
 
Index: src/test/java/net/sf/ehcache/store/LfuMemoryStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/store/LfuMemoryStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/store/LfuMemoryStoreTest.java	(working copy)
@@ -16,18 +16,9 @@
 
 package net.sf.ehcache.store;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.MemoryStoreTester;
-import net.sf.ehcache.Statistics;
-import net.sf.ehcache.StopWatch;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -37,8 +28,19 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.MemoryStoreTester;
+import net.sf.ehcache.Statistics;
+import net.sf.ehcache.StopWatch;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Test class for LfuMemoryStore
@@ -49,7 +51,7 @@
  */
 public class LfuMemoryStoreTest extends MemoryStoreTester {
 
-    private static final Logger LOG = Logger.getLogger(LfuMemoryStoreTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(LfuMemoryStoreTest.class);
 
     /**
      * setup test
@@ -230,11 +232,11 @@
         for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {
             String string = (String) iterator.next();
             int thisReading = Integer.parseInt(string);
-            LOG.log(Level.INFO, "reading: " + thisReading);
+            LOG.info("reading: " + thisReading);
             absoluteDifferences += Math.abs(lastReading - thisReading);
             lastReading = thisReading;
         }
-        LOG.log(Level.FINE, "Mean difference through iteration: " + absoluteDifferences / 500);
+        LOG.debug("Mean difference through iteration: " + absoluteDifferences / 500);
 
         //Random selection without replacement
         Random random = new Random();
@@ -247,8 +249,8 @@
             absoluteDifferences += Math.abs(lastReading - thisReading);
             lastReading = thisReading;
         }
-        LOG.log(Level.INFO, "Mean difference with random selection without replacement : " + absoluteDifferences / 500);
-        LOG.log(Level.INFO, "Mean of range 1 - 500 : " + mean);
+        LOG.info("Mean difference with random selection without replacement : " + absoluteDifferences / 500);
+        LOG.info("Mean of range 1 - 500 : " + mean);
 
     }
 
@@ -271,13 +273,13 @@
         for (int i = 1; i <= 100000; i++) {
             map.put(i, i);
         }
-        LOG.log(Level.INFO, "done putting: " + stopWatch.getElapsedTimeString());
+        LOG.info("done putting: " + stopWatch.getElapsedTimeString());
 
         Collection collection = map.values();
         for (Object o : collection) {
             o.toString();
         }
-        LOG.log(Level.INFO, stopWatch.getElapsedTimeString());
+        LOG.info(stopWatch.getElapsedTimeString());
 
     }
 
@@ -388,9 +390,9 @@
                 lowestQuarterNotIdentified++;
             }
         }
-        LOG.log(Level.INFO, "Find time: " + findTime);
+        LOG.info("Find time: " + findTime);
         assertTrue(findTime < 200);
-        LOG.log(Level.INFO, "Selections not in lowest quartile: " + lowestQuarterNotIdentified);
+        LOG.info("Selections not in lowest quartile: " + lowestQuarterNotIdentified);
         assertTrue(lowestQuarterNotIdentified <= 10);
 
     }
@@ -431,7 +433,7 @@
         getTestBean(cache, "test2");
 
         Statistics stats = cache.getStatistics();
-        LOG.log(Level.INFO, stats.toString());
+        LOG.info(stats.toString());
 
         cacheManager.shutdown();
     }
Index: src/test/java/net/sf/ehcache/store/LruClassicMemoryStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/store/LruClassicMemoryStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/store/LruClassicMemoryStoreTest.java	(working copy)
@@ -1,6 +1,7 @@
 package net.sf.ehcache.store;
 
 import net.sf.ehcache.Cache;
+
 import org.junit.After;
 import org.junit.Before;
 
Index: src/test/java/net/sf/ehcache/config/ConfigurationFactoryTest.java
===================================================================
--- src/test/java/net/sf/ehcache/config/ConfigurationFactoryTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/config/ConfigurationFactoryTest.java	(working copy)
@@ -17,31 +17,11 @@
 
 package net.sf.ehcache.config;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
-import net.sf.ehcache.distribution.CacheManagerPeerListener;
-import net.sf.ehcache.distribution.CacheManagerPeerProvider;
-import net.sf.ehcache.distribution.MulticastRMICacheManagerPeerProvider;
-import net.sf.ehcache.distribution.RMIAsynchronousCacheReplicator;
-import net.sf.ehcache.distribution.RMIBootstrapCacheLoader;
-import net.sf.ehcache.distribution.RMICacheManagerPeerListener;
-import net.sf.ehcache.event.CacheEventListener;
-import net.sf.ehcache.event.CacheManagerEventListener;
-import net.sf.ehcache.event.CountingCacheEventListener;
-import net.sf.ehcache.event.CountingCacheManagerEventListener;
-import net.sf.ehcache.exceptionhandler.CacheExceptionHandler;
-import net.sf.ehcache.exceptionhandler.CountingExceptionHandler;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -58,10 +38,31 @@
 import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarOutputStream;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.regex.Matcher;
 
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
+import net.sf.ehcache.distribution.CacheManagerPeerListener;
+import net.sf.ehcache.distribution.CacheManagerPeerProvider;
+import net.sf.ehcache.distribution.MulticastRMICacheManagerPeerProvider;
+import net.sf.ehcache.distribution.RMIAsynchronousCacheReplicator;
+import net.sf.ehcache.distribution.RMIBootstrapCacheLoader;
+import net.sf.ehcache.distribution.RMICacheManagerPeerListener;
+import net.sf.ehcache.event.CacheEventListener;
+import net.sf.ehcache.event.CacheManagerEventListener;
+import net.sf.ehcache.event.CountingCacheEventListener;
+import net.sf.ehcache.event.CountingCacheManagerEventListener;
+import net.sf.ehcache.exceptionhandler.CacheExceptionHandler;
+import net.sf.ehcache.exceptionhandler.CountingExceptionHandler;
+
+import org.junit.Before;
+import org.junit.Test;
+
 /**
  * Tests for Store Configuration
  * <p/>
@@ -956,7 +957,7 @@
         String propertyWithQuotesProtected = Matcher.quoteReplacement(property);
         configuration = configuration.replaceAll("\\$\\{" + trimmedToken + "\\}", propertyWithQuotesProtected);
         assertTrue(configuration.contains(property));
-        LOG.log(Level.INFO, "configuration is: " + configuration);
+        LOG.info("configuration is: " + configuration);
 
 
     }
Index: src/test/java/net/sf/ehcache/config/ConfigurationHelperTest.java
===================================================================
--- src/test/java/net/sf/ehcache/config/ConfigurationHelperTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/config/ConfigurationHelperTest.java	(working copy)
@@ -16,17 +16,19 @@
 
 package net.sf.ehcache.config;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.CacheManager;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.File;
 import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.CacheManager;
+
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Tests programmatically constructed Configuration instances
@@ -36,7 +38,7 @@
  */
 public class ConfigurationHelperTest extends AbstractCacheTest {
 
-    private static final Logger LOG = Logger.getLogger(ConfigurationHelperTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ConfigurationHelperTest.class);
 
 
     /**
@@ -63,7 +65,7 @@
             fail();
         } catch (Exception e) {
             //expected
-            LOG.log(Level.FINE, "Expected exception " + e.getMessage() + ". Initial cause was " + e.getMessage(), e);
+            LOG.debug("Expected exception " + e.getMessage() + ". Initial cause was " + e.getMessage(), e);
         }
     }
 
Index: src/test/java/net/sf/ehcache/StatisticsTest.java
===================================================================
--- src/test/java/net/sf/ehcache/StatisticsTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/StatisticsTest.java	(working copy)
@@ -21,16 +21,16 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.junit.Test;
+
 /**
  * Tests for the statistics class
  *
@@ -194,9 +194,9 @@
         long value = Integer.MAX_VALUE;
         value += Integer.MAX_VALUE;
         value += 5;
-        LOG.log(Level.INFO, "" + value);
+        LOG.info("" + value);
         int valueAsInt = (int) value;
-        LOG.log(Level.INFO, "" + valueAsInt);
+        LOG.info("" + valueAsInt);
         assertEquals(3, valueAsInt);
 
     }
Index: src/test/java/net/sf/ehcache/StopWatch.java
===================================================================
--- src/test/java/net/sf/ehcache/StopWatch.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/StopWatch.java	(working copy)
@@ -17,10 +17,11 @@
 package net.sf.ehcache;
 
 
+
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A timer service used to check performance of tests.
@@ -44,7 +45,7 @@
  */
 public class StopWatch {
 
-    private static final Logger LOG = Logger.getLogger(StopWatch.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(StopWatch.class);
 
 
     private static final String SUFFIX = "ms";
@@ -79,15 +80,15 @@
             try {
                 speedAdjustmentFactor = Float.parseFloat(speedAdjustmentFactorString);
             } catch (NumberFormatException e) {
-                LOG.log(Level.FINE, "Consider setting system property 'net.sf.ehcache.speedAdjustmentFactor=n' " +
+                LOG.debug("Consider setting system property 'net.sf.ehcache.speedAdjustmentFactor=n' " +
                         "where n is the number of times your machine is slower than the reference machine, " +
                         "which is currently a dual G5 PowerMac. e.g. 1.2, which then enables elasped time " +
                         "measurement to be adjusted accordingly.");
             }
-            LOG.log(Level.FINE, "Using speedAjustmentFactor of " + speedAdjustmentFactor);
+            LOG.debug("Using speedAjustmentFactor of " + speedAdjustmentFactor);
 
         } else {
-            LOG.log(Level.FINE, "Consider setting system property 'net.sf.ehcache.speedAdjustmentFactor=n' " +
+            LOG.debug("Consider setting system property 'net.sf.ehcache.speedAdjustmentFactor=n' " +
                     "where n is the number of times your machine is slower than the reference machine, " +
                     "which is currently a dual G5 PowerMac. e.g. 1.2, which then enables elasped time " +
                     "measurement to be adjusted accordingly.");
@@ -99,7 +100,7 @@
         } catch (InterruptedException e) {
             //
         }
-        LOG.log(Level.FINE, "100 measures as " + stopWatch.getElapsedTime());
+        LOG.debug("100 measures as " + stopWatch.getElapsedTime());
 
 
     }
@@ -132,12 +133,12 @@
 //        }
 //        long elapsedTime = System.currentTimeMillis() - start;
 //
-//        LOG.log(Level.SEVERE, "It took this machine: " + elapsedTime + " to perform a time trial compared with the reference time of "
+//        LOG.error("It took this machine: " + elapsedTime + " to perform a time trial compared with the reference time of "
 //                + referenceTime + "ms");
 //
 //        speedAdjustmentFactor = elapsedTime / referenceTime;
 //
-//        LOG.log(Level.SEVERE, "Elapsed stopwatch times will be adjusted divided by " + speedAdjustmentFactor);
+//        LOG.error("Elapsed stopwatch times will be adjusted divided by " + speedAdjustmentFactor);
 //    }
 
 
Index: src/test/java/net/sf/ehcache/CacheClassicLruMemoryStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/CacheClassicLruMemoryStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/CacheClassicLruMemoryStoreTest.java	(working copy)
@@ -1,15 +1,16 @@
 package net.sf.ehcache;
 
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-import org.junit.AfterClass;
 import static org.junit.Assert.assertEquals;
-import org.junit.BeforeClass;
-import org.junit.Test;
 
 import java.util.Date;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
 /**
  * Does the cache tests using the classic LRUMemoryStore implementation.
  * @author Greg Luck
@@ -110,7 +111,7 @@
         //this one does
         cache.put(new Element("nullValue", null));
 
-        LOG.log(Level.INFO, "Size: " + cache.getDiskStoreSize());
+        LOG.info("Size: " + cache.getDiskStoreSize());
 
         assertEquals(50, cache.getMemoryStoreSize());
         assertEquals(54, cache.getDiskStoreSize());
Index: src/test/java/net/sf/ehcache/StatusTest.java
===================================================================
--- src/test/java/net/sf/ehcache/StatusTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/StatusTest.java	(working copy)
@@ -18,11 +18,11 @@
 
 
 import static org.junit.Assert.assertTrue;
-import org.junit.Test;
 
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.junit.Test;
+
 
 /**
  * Test cases for status.
@@ -59,7 +59,7 @@
             status1.equals(status2);
         }
         long statusCompareTime = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to do equals(Status): " + statusCompareTime);
+        LOG.info("Time to do equals(Status): " + statusCompareTime);
         assertTrue("Status compare is greater than permitted time", statusCompareTime < 35);
 
     }
@@ -82,7 +82,7 @@
             status1.equals(object);
         }
         long objectCompareTime = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to do equals(Object): " + objectCompareTime);
+        LOG.info("Time to do equals(Object): " + objectCompareTime);
         assertTrue("Status compare is greater than permitted time", objectCompareTime < 25);
 
 
@@ -107,7 +107,7 @@
             result = int1 == int2;
         }
         long intCompareTime = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to do int == int: " + intCompareTime);
+        LOG.info("Time to do int == int: " + intCompareTime);
         assertTrue("Status compare is greater than permitted time", intCompareTime < 10);
 
 
Index: src/test/java/net/sf/ehcache/event/CountingCacheEventListener.java
===================================================================
--- src/test/java/net/sf/ehcache/event/CountingCacheEventListener.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/CountingCacheEventListener.java	(working copy)
@@ -16,15 +16,15 @@
 
 package net.sf.ehcache.event;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+
 /**
  * Counts listener notifications.
  * <p/>
Index: src/test/java/net/sf/ehcache/event/TestCacheManagerEventListenerFactory.java
===================================================================
--- src/test/java/net/sf/ehcache/event/TestCacheManagerEventListenerFactory.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/TestCacheManagerEventListenerFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.event;
 
-import net.sf.ehcache.util.PropertyUtil;
-
 import java.util.Properties;
 
+import net.sf.ehcache.util.PropertyUtil;
+
 /**
  * A factory which creates a counter, for testing purposes
  *
Index: src/test/java/net/sf/ehcache/event/NullCacheEventListener.java
===================================================================
--- src/test/java/net/sf/ehcache/event/NullCacheEventListener.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/NullCacheEventListener.java	(working copy)
@@ -20,8 +20,9 @@
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 
 /**
@@ -33,28 +34,26 @@
  */
 public class NullCacheEventListener implements CacheEventListener {
 
-    private static final Logger LOG = Logger.getLogger(NullCacheEventListener.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(NullCacheEventListener.class);
 
 
     /**
      * {@inheritDoc}
      */
     public void notifyElementRemoved(final Ehcache cache, final Element element) {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine("notifyElementRemoved called for cache " + cache + " for element with key " + element.getObjectKey());
-        }
+        LOG.debug("notifyElementRemoved called for cache {} for element with key {}", cache, element.getObjectKey());
     }
 
     /**
      * {@inheritDoc}
      */
     public void notifyElementPut(final Ehcache cache, final Element element) {
-        if (LOG.isLoggable(Level.FINE)) {
+        if (LOG.isDebugEnabled()) {
             Object key = null;
             if (element != null) {
                 key = element.getObjectKey();
             }
-            LOG.fine("notifyElementPut called for cache " + cache + " for element with key " + key);
+            LOG.debug("notifyElementPut called for cache {} for element with key {}", cache, key);
         }
     }
 
@@ -72,12 +71,12 @@
      * @param element the element which was just put into the cache.
      */
     public void notifyElementUpdated(final Ehcache cache, final Element element) throws CacheException {
-        if (LOG.isLoggable(Level.FINE)) {
+        if (LOG.isDebugEnabled()) {
             Object key = null;
             if (element != null) {
                 key = element.getObjectKey();
             }
-            LOG.fine("notifyElementUpdated called for cache " + cache + " for element with key " + key);
+            LOG.debug("notifyElementUpdated called for cache {} for element with key ", cache, key);
         }
     }
 
@@ -85,8 +84,8 @@
      * {@inheritDoc}
      */
     public void notifyElementExpired(final Ehcache cache, final Element element) {
-        if (LOG.isLoggable(Level.FINE)) {
-            LOG.fine("notifyElementExpired called for cache " + cache + " for element with key " + element.getObjectKey());
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("notifyElementExpired called for cache {} for element with key {}", cache, element.getObjectKey());
         }
     }
 
Index: src/test/java/net/sf/ehcache/event/CountingCacheManagerEventListener.java
===================================================================
--- src/test/java/net/sf/ehcache/event/CountingCacheManagerEventListener.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/CountingCacheManagerEventListener.java	(working copy)
@@ -16,12 +16,12 @@
 
 package net.sf.ehcache.event;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Status;
-
 import java.util.ArrayList;
 import java.util.List;
 
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Status;
+
 
 /**
  * A counting cache manager listener.
Index: src/test/java/net/sf/ehcache/event/CacheManagerEventListenerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/event/CacheManagerEventListenerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/CacheManagerEventListenerTest.java	(working copy)
@@ -17,14 +17,15 @@
 package net.sf.ehcache.event;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.config.CacheConfiguration;
 import net.sf.ehcache.constructs.blocking.SelfPopulatingCache;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import org.junit.Before;
 import org.junit.Test;
 
Index: src/test/java/net/sf/ehcache/event/ProgrammaticallyCreatedCacheEventListenerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/event/ProgrammaticallyCreatedCacheEventListenerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/ProgrammaticallyCreatedCacheEventListenerTest.java	(working copy)
@@ -16,9 +16,10 @@
 
 package net.sf.ehcache.event;
 
+import static org.junit.Assert.assertEquals;
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheManager;
-import static org.junit.Assert.assertEquals;
+
 import org.junit.Before;
 import org.junit.Test;
 
Index: src/test/java/net/sf/ehcache/event/CacheEventListenerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/event/CacheEventListenerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/event/CacheEventListenerTest.java	(working copy)
@@ -16,27 +16,29 @@
 
 package net.sf.ehcache.event;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * Tests the cache listener functionality
@@ -46,7 +48,7 @@
  */
 public class CacheEventListenerTest extends AbstractCacheTest {
 
-    private static final Logger LOG = Logger.getLogger(CacheEventListenerTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(CacheEventListenerTest.class);
 
 
     /**
@@ -755,7 +757,7 @@
                         assertTrue(cache.getCacheEventNotificationService().unregisterListener(listener));
 
                     } catch (Throwable t) {
-                        LOG.log(Level.SEVERE, "", t);
+                        LOG.error("", t);
                         fail();
                     }
                 }
Index: src/test/java/net/sf/ehcache/DiskStoreTest.java
===================================================================
--- src/test/java/net/sf/ehcache/DiskStoreTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/DiskStoreTest.java	(working copy)
@@ -16,18 +16,12 @@
 
 package net.sf.ehcache;
 
-import net.sf.ehcache.config.DiskStoreConfiguration;
-import net.sf.ehcache.store.DiskStore;
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-import net.sf.ehcache.store.Primitive;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -40,9 +34,16 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.config.DiskStoreConfiguration;
+import net.sf.ehcache.store.DiskStore;
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+import net.sf.ehcache.store.Primitive;
+
+import org.junit.After;
+import org.junit.Test;
+
 /**
  * Test cases for the DiskStore.
  *
@@ -854,9 +855,9 @@
             waitLonger();
             int predictedSize = 140800;
             long actualSize = diskStore.getDataFileSize();
-            LOG.log(Level.INFO, "Predicted Size: " + predictedSize + " Actual Size: " + actualSize);
+            LOG.info("Predicted Size: " + predictedSize + " Actual Size: " + actualSize);
             assertEquals(predictedSize, actualSize);
-            LOG.log(Level.INFO, "Memory Use: " + measureMemoryUse());
+            LOG.info("Memory Use: " + measureMemoryUse());
         }
 
 
@@ -995,7 +996,7 @@
                             + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"));
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "time: " + time);
+        LOG.info("time: " + time);
         assertTrue(4 < time);
     }
 
@@ -1018,7 +1019,7 @@
             random.nextBytes(bytes);
             cache.put(new Element("" + i, bytes));
         }
-        LOG.log(Level.INFO, "Elements written: " + i);
+        LOG.info("Elements written: " + i);
         //Thread.sleep(100000);
     }
 
@@ -1048,7 +1049,7 @@
 
 
         long elapsed = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Elapsed time: " + elapsed / 1000);
+        LOG.info("Elapsed time: " + elapsed / 1000);
         Thread.sleep(500);
         assertEquals(100000, cache.getSize());
         assertTrue(23 < elapsed);
@@ -1101,10 +1102,10 @@
                 Thread.sleep(2000);
             }
             long elapsed = stopWatch.getElapsedTime();
-            LOG.log(Level.INFO, "Elapsed time: " + elapsed / 1000);
+            LOG.info("Elapsed time: " + elapsed / 1000);
             fail();
         } catch (OutOfMemoryError e) {
-            LOG.log(Level.INFO, "All heap consumed after " + index + " entries created.");
+            LOG.info("All heap consumed after " + index + " entries created.");
             int expectedMax = 3090000;
             assertTrue("Achieved " + index.intValue() + " which was less than the expected value of " + expectedMax,
                     index.intValue() >= expectedMax);
@@ -1148,7 +1149,7 @@
         }
         long elapsed = stopWatch.getElapsedTime();
         long putTime = ((elapsed / 1000) - 10);
-        LOG.log(Level.INFO, "Put Elapsed time: " + putTime);
+        LOG.info("Put Elapsed time: " + putTime);
         assertTrue(putTime < 20);
 
         //wait for Disk Store to finish spooling
@@ -1166,7 +1167,7 @@
 
         long getElapsedTime = getStopWatch.getElapsedTime();
         int time = (int) ((getElapsedTime - getStart) / 1000);
-        LOG.log(Level.INFO, "Get Elapsed time: " + time);
+        LOG.info("Get Elapsed time: " + time);
 
         assertTrue(time < 180);
 
Index: src/test/java/net/sf/ehcache/exceptionhandler/CacheExceptionHandlerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/exceptionhandler/CacheExceptionHandlerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/exceptionhandler/CacheExceptionHandlerTest.java	(working copy)
@@ -17,6 +17,12 @@
 package net.sf.ehcache.exceptionhandler;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
@@ -24,15 +30,11 @@
 import net.sf.ehcache.event.CountingCacheEventListener;
 import net.sf.ehcache.loader.CacheLoader;
 import net.sf.ehcache.loader.ExceptionThrowingLoader;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * @author <a href="mailto:gluck@gregluck.com">Greg Luck</a>
  * @version $Id$
Index: src/test/java/net/sf/ehcache/exceptionhandler/CountingExceptionHandler.java
===================================================================
--- src/test/java/net/sf/ehcache/exceptionhandler/CountingExceptionHandler.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/exceptionhandler/CountingExceptionHandler.java	(working copy)
@@ -16,11 +16,11 @@
 
 package net.sf.ehcache.exceptionhandler;
 
-import net.sf.ehcache.Ehcache;
-
 import java.util.ArrayList;
 import java.util.List;
 
+import net.sf.ehcache.Ehcache;
+
 /**
  * A test handler, used to test the Exception handling mechanism
  *
Index: src/test/java/net/sf/ehcache/exceptionhandler/CustomExceptionThrowingLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/exceptionhandler/CustomExceptionThrowingLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/exceptionhandler/CustomExceptionThrowingLoader.java	(working copy)
@@ -32,16 +32,17 @@
  *  limitations under the License.
  */
 
+import java.util.Collection;
+import java.util.Map;
+import java.util.Random;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Status;
 import net.sf.ehcache.loader.CacheLoader;
 
-import java.util.Collection;
-import java.util.Map;
-import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -55,7 +56,7 @@
  */
 public class CustomExceptionThrowingLoader implements CacheLoader {
 
-    private static final Logger LOG = Logger.getLogger(CustomExceptionThrowingLoader.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(CustomExceptionThrowingLoader.class);
 
     private Random random = new Random();
     private String name = "CustomExceptionThrowingLoader";
@@ -75,7 +76,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new UnsupportedOperationException("load not supported by CustomExceptionThrowingLoader");
     }
@@ -97,7 +98,7 @@
         try {
             Thread.sleep(random.nextInt(4));
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new UnsupportedOperationException("loadAll not supported by CustomExceptionThrowingLoader");
 
@@ -119,7 +120,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new UnsupportedOperationException("2-arg load not supported by CustomExceptionThrowingLoader");
     }
@@ -139,7 +140,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new UnsupportedOperationException("2-arg loadAll not supported by CustomExceptionThrowingLoader");
     }
Index: src/test/java/net/sf/ehcache/ConcurrencyProblemCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/ConcurrencyProblemCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/ConcurrencyProblemCacheTest.java	(working copy)
@@ -17,17 +17,17 @@
 
 package net.sf.ehcache;
 
-import org.junit.After;
 import static org.junit.Assert.assertTrue;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 
 /**
  * Demonstrates a problem with Ben Manes' ConcurrentLinkedHashmap. This was used in beta4 but was found not to be
@@ -67,7 +67,7 @@
         cache = manager.getCache("sampleIdlingExpiringCache");
         for (int i = 0; i < 5; i++) {
             thrashCache(cache, 1500L);
-            LOG.log(Level.INFO, "Finished run.");
+            LOG.info("Finished run.");
         }
     }
 
@@ -77,7 +77,7 @@
         manager.addCache(cache);
         for (int i = 0; i < 5; i++) {
             thrashCache(cache, 1500L);
-            LOG.log(Level.INFO, "Finished run.");
+            LOG.info("Finished run.");
 
         }
     }
Index: src/test/java/net/sf/ehcache/loader/ComponentALoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/ComponentALoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/ComponentALoader.java	(working copy)
@@ -17,11 +17,10 @@
 package net.sf.ehcache.loader;
 
 
-import net.sf.ehcache.CacheException;
-
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.CacheException;
+
 
 /**
  * Written for Dead-lock poc
@@ -52,7 +51,7 @@
 
         boolean createDeadLock = Boolean.valueOf(props.getProperty("createDeadLock")).booleanValue();
 
-        LOG.log(Level.INFO, "createDeadLock=" + createDeadLock);
+        LOG.info("createDeadLock=" + createDeadLock);
 
         if (createDeadLock) {
             key = (String) arg0;
@@ -60,7 +59,7 @@
             key = new String((String) arg0);
         }
 
-        LOG.log(Level.INFO, "Getting componentB...");
+        LOG.info("Getting componentB...");
         b = (ComponentB) CacheHelper.get("ehcache-loaderinteractions.xml", "BCache", key);
 
         return new ComponentA(key, b);
Index: src/test/java/net/sf/ehcache/loader/NullCountingCacheLoaderFactory.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/NullCountingCacheLoaderFactory.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/NullCountingCacheLoaderFactory.java	(working copy)
@@ -17,11 +17,11 @@
 package net.sf.ehcache.loader;
 
 
-import net.sf.ehcache.Ehcache;
-
 import java.util.Map;
 import java.util.Properties;
 
+import net.sf.ehcache.Ehcache;
+
 /**
  * A factory for creating counting cache loaders. This can be hooked up to the JCacheFactory by
  * specifying "cacheLoaderFactoryClassName" in the environment
Index: src/test/java/net/sf/ehcache/loader/CountingCacheLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/CountingCacheLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/CountingCacheLoader.java	(working copy)
@@ -16,18 +16,19 @@
 
 package net.sf.ehcache.loader;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Status;
-
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Status;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * A cache loader that counts the number of things it has loaded, useful for testing.
@@ -40,7 +41,7 @@
  */
 public class CountingCacheLoader implements CacheLoader {
 
-    private static final Logger LOG = Logger.getLogger(CountingCacheLoader.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(CountingCacheLoader.class);
 
     private volatile int loadCounter;
     private volatile int loadAllCounter;
@@ -61,7 +62,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         return new Integer(loadCounter++);
     }
@@ -84,7 +85,7 @@
             try {
                 Thread.sleep(random.nextInt(4));
             } catch (InterruptedException e) {
-                LOG.log(Level.SEVERE, "Interrupted");
+                LOG.error("Interrupted");
             }
             map.put(key, new Integer(loadAllCounter++));
         }
@@ -120,7 +121,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         return name + ":" + argument;
     }
Index: src/test/java/net/sf/ehcache/loader/BaseComponentLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/BaseComponentLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/BaseComponentLoader.java	(working copy)
@@ -16,14 +16,14 @@
 
 package net.sf.ehcache.loader;
 
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Status;
-
 import java.util.Collection;
 import java.util.Map;
 import java.util.Properties;
 
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Status;
+
 
 /**
  * Written for Dead-lock poc
Index: src/test/java/net/sf/ehcache/loader/CacheHelper.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/CacheHelper.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/CacheHelper.java	(working copy)
@@ -16,15 +16,15 @@
 
 package net.sf.ehcache.loader;
 
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
 /**
  * Written for Dead-lock poc
  *
Index: src/test/java/net/sf/ehcache/loader/ExceptionThrowingLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/ExceptionThrowingLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/ExceptionThrowingLoader.java	(working copy)
@@ -17,16 +17,17 @@
 package net.sf.ehcache.loader;
 
 
-import net.sf.ehcache.CacheException;
-
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
+import net.sf.ehcache.CacheException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * A cache loader that throws exceptions when used
@@ -38,7 +39,7 @@
  */
 public class ExceptionThrowingLoader extends CountingCacheLoader {
 
-    private static final Logger LOG = Logger.getLogger(ExceptionThrowingLoader.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ExceptionThrowingLoader.class);
 
     private int loadCounter;
     private int loadAllCounter;
@@ -59,7 +60,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new CacheException("Some exception with key " + key);
     }
@@ -82,7 +83,7 @@
             try {
                 Thread.sleep(random.nextInt(4));
             } catch (InterruptedException e) {
-                LOG.log(Level.SEVERE, "Interrupted");
+                LOG.error("Interrupted");
             }
             map.put(key, new Integer(loadAllCounter++));
             throw new CacheException("Some exception with key " + key);
@@ -101,7 +102,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         throw new CacheException("Some exception with key " + key);
     }
Index: src/test/java/net/sf/ehcache/loader/ComponentBLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/ComponentBLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/ComponentBLoader.java	(working copy)
@@ -16,11 +16,10 @@
 
 package net.sf.ehcache.loader;
 
-import net.sf.ehcache.CacheException;
-
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.CacheException;
+
 
 /**
  * Written for Dead-lock poc
@@ -45,7 +44,7 @@
      * @throws CacheException
      */
     public Object load(Object arg0) throws CacheException {
-        LOG.log(Level.INFO, "Loading Component B...");
+        LOG.info("Loading Component B...");
         String key = (String) arg0;
         return new ComponentB(key);
     }
Index: src/test/java/net/sf/ehcache/loader/CountingCacheLoaderFactory.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/CountingCacheLoaderFactory.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/CountingCacheLoaderFactory.java	(working copy)
@@ -17,11 +17,11 @@
 package net.sf.ehcache.loader;
 
 
-import net.sf.ehcache.Ehcache;
-
 import java.util.Map;
 import java.util.Properties;
 
+import net.sf.ehcache.Ehcache;
+
 /**
  * A factory for creating counting cache loaders. This can be hooked up to the JCacheFactory by
  * specifying "cacheLoaderFactoryClassName" in the environment
Index: src/test/java/net/sf/ehcache/loader/NullCountingCacheLoader.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/NullCountingCacheLoader.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/NullCountingCacheLoader.java	(working copy)
@@ -16,15 +16,16 @@
 
 package net.sf.ehcache.loader;
 
+import java.util.Collection;
+import java.util.Map;
+import java.util.Random;
+
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Status;
 
-import java.util.Collection;
-import java.util.Map;
-import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -39,7 +40,7 @@
  */
 public class NullCountingCacheLoader implements CacheLoader {
 
-    private static final Logger LOG = Logger.getLogger(NullCountingCacheLoader.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(NullCountingCacheLoader.class);
 
     private volatile int loadCounter;
     private volatile int loadAllCounter;
@@ -60,7 +61,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         loadCounter++;
         return null;
@@ -111,7 +112,7 @@
         try {
             Thread.sleep(random.nextInt(3) + 1);
         } catch (InterruptedException e) {
-            LOG.log(Level.SEVERE, "Interrupted");
+            LOG.error("Interrupted");
         }
         return name + ":" + argument;
     }
Index: src/test/java/net/sf/ehcache/loader/CompositeLoaderTest.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/CompositeLoaderTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/CompositeLoaderTest.java	(working copy)
@@ -17,13 +17,12 @@
 package net.sf.ehcache.loader;
 
 
+import java.util.logging.Logger;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 
 /**
  * ComponentA is composed of ComponentB and some other fields. Tests the interactions between two loaders, where the first component's
@@ -59,9 +58,9 @@
      */
     @Test
     public void testCompositeLoad() {
-        LOG.log(Level.INFO, "Getting from cache");
+        LOG.info("Getting from cache");
         ComponentA compA = (ComponentA) CacheHelper.get("ehcache-loaderinteractions.xml", "ACache", "key1");
-        LOG.log(Level.INFO, compA.toString());
+        LOG.info(compA.toString());
 
     }
 
Index: src/test/java/net/sf/ehcache/loader/CacheLoaderTest.java
===================================================================
--- src/test/java/net/sf/ehcache/loader/CacheLoaderTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/loader/CacheLoaderTest.java	(working copy)
@@ -17,21 +17,23 @@
 package net.sf.ehcache.loader;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import java.util.List;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.Status;
 import net.sf.ehcache.extension.TestCacheExtension;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.List;
-
 /**
  * @author <a href="mailto:gluck@gregluck.com">Greg Luck</a>
  * @version $Id$
Index: src/test/java/net/sf/ehcache/MemoryStoreTester.java
===================================================================
--- src/test/java/net/sf/ehcache/MemoryStoreTester.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/MemoryStoreTester.java	(working copy)
@@ -16,26 +16,27 @@
 
 package net.sf.ehcache;
 
-import net.sf.ehcache.store.LruMemoryStoreTest;
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-import net.sf.ehcache.store.Store;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.store.LruMemoryStoreTest;
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+import net.sf.ehcache.store.Store;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 /**
  * Other than policy differences, the Store implementations should work identically
  *
@@ -85,10 +86,10 @@
             }
         } catch (OutOfMemoryError e) {
             //OutOfMemoryError Happens at different places on Apache LRU for some reason
-            LOG.log(Level.INFO, e.getMessage());
+            LOG.info(e.getMessage());
         } catch (Throwable t) {
             //OutOfMemoryError Happens at different places on Apache LRU for some reason
-            LOG.log(Level.INFO, t.getMessage());
+            LOG.info(t.getMessage());
         }
     }
 
@@ -361,7 +362,7 @@
             assertNotNull(element);
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for Bulk Load: " + time);
+        LOG.info("Time for Bulk Load: " + time);
     }
 
     /**
@@ -383,7 +384,7 @@
             store.remove(key + i);
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for benchmarkPutGetRemove: " + time);
+        LOG.info("Time for benchmarkPutGetRemove: " + time);
         assertTrue("Too slow. Time was " + time, time < 500);
     }
 
@@ -406,7 +407,7 @@
             store.get(key + i);
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for benchmarkPutGet: " + time);
+        LOG.info("Time for benchmarkPutGet: " + time);
         assertTrue("Too slow. Time was " + time, time < 300);
     }
 
@@ -443,7 +444,7 @@
             store.put(element);
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for putSpeed: " + time);
+        LOG.info("Time for putSpeed: " + time);
         assertTrue("Too slow. Time was " + time, time < 4000);
     }
 
@@ -472,7 +473,7 @@
             }
         }
         long time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for benchmarkPutGetSurya: " + time);
+        LOG.info("Time for benchmarkPutGetSurya: " + time);
         assertTrue("Too slow. Time was " + time, time < allowedTime);
     }
 
@@ -546,7 +547,7 @@
     @Test
     public void testMemoryLeak() throws Exception {
         long differenceMemoryCache = thrashCache();
-        LOG.log(Level.INFO, "Difference is : " + differenceMemoryCache);
+        LOG.info("Difference is : " + differenceMemoryCache);
         //Sometimes this can be higher but a three hour run confirms no memory leak. Consider increasing.
         assertTrue(differenceMemoryCache < 500000);
     }
@@ -559,7 +560,7 @@
 
 
         long startingSize = measureMemoryUse();
-        LOG.log(Level.INFO, "Starting memory used is: " + startingSize);
+        LOG.info("Starting memory used is: " + startingSize);
 
         final String value = "value";
         final String key = "key";
@@ -604,7 +605,7 @@
         store.removeAll();
 
         long finishingSize = measureMemoryUse();
-        LOG.log(Level.INFO, "Ending memory used is: " + finishingSize);
+        LOG.info("Ending memory used is: " + finishingSize);
         return finishingSize - startingSize;
     }
 
@@ -651,7 +652,7 @@
 
         runThreads(executables);
         long end = System.currentTimeMillis();
-        LOG.log(Level.INFO, "Total time for the test: " + (end + start) + " ms");
+        LOG.info("Total time for the test: " + (end + start) + " ms");
     }
 
 
@@ -669,7 +670,7 @@
      */
     @Test
     public void testMemoryStoreOutOfMemoryLimit() throws Exception {
-        LOG.log(Level.INFO, "Starting out of memory limit test");
+        LOG.info("Starting out of memory limit test");
         //Set size so the second element overflows to disk.
         cache = manager.getCache("memoryLimitTest");
         if (cache == null) {
@@ -687,7 +688,7 @@
                         + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                         + "AAAAA " + i));
             }
-            LOG.log(Level.INFO, "About to fail out of memory limit test");
+            LOG.info("About to fail out of memory limit test");
             fail();
         } catch (OutOfMemoryError e) {
             System.gc();
@@ -695,7 +696,7 @@
             System.gc();
 
             try {
-                LOG.log(Level.INFO, "Ran out of memory putting " + i + "th element");
+                LOG.info("Ran out of memory putting " + i + "th element");
                 assertTrue(i > 65000);
             } catch (OutOfMemoryError e1) {
                 //sometimes if we are really out of memory we cannot do anything
Index: src/test/java/net/sf/ehcache/CachePerformanceTest.java
===================================================================
--- src/test/java/net/sf/ehcache/CachePerformanceTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/CachePerformanceTest.java	(working copy)
@@ -1,13 +1,13 @@
 package net.sf.ehcache;
 
-import org.junit.After;
 import static org.junit.Assert.assertTrue;
-import org.junit.Before;
-import org.junit.Test;
 
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 /**
  * Isolated performance test which only runs one cache at a time.
  *
@@ -71,7 +71,7 @@
             m500d500Cache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to get 50000 entries from m500d45500Cache: " + time);
+        LOG.info("Time to get 50000 entries from m500d45500Cache: " + time);
         assertTrue("Time to get 50000 entries from m500d500Cache", time < 20000);
     }
 
@@ -103,7 +103,7 @@
             m500d500Cache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to get 50000 entries from m50000Cache: " + time);
+        LOG.info("Time to get 50000 entries from m50000Cache: " + time);
         assertTrue("Time to get 50000 entries from m50000Cache", time < 20000);
     }
 
Index: src/test/java/net/sf/ehcache/extension/TestCacheExtensionFactory.java
===================================================================
--- src/test/java/net/sf/ehcache/extension/TestCacheExtensionFactory.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/extension/TestCacheExtensionFactory.java	(working copy)
@@ -16,11 +16,11 @@
 
 package net.sf.ehcache.extension;
 
+import java.util.Properties;
+
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.util.PropertyUtil;
 
-import java.util.Properties;
-
 /**
  * @author <a href="mailto:gluck@gregluck.com">Greg Luck</a>
  * @version $Id$
Index: src/test/java/net/sf/ehcache/extension/CacheExtensionTest.java
===================================================================
--- src/test/java/net/sf/ehcache/extension/CacheExtensionTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/extension/CacheExtensionTest.java	(working copy)
@@ -16,14 +16,15 @@
 
 package net.sf.ehcache.extension;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Status;
 import net.sf.ehcache.event.CountingCacheEventListener;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import org.junit.Before;
 import org.junit.Test;
 
Index: src/test/java/net/sf/ehcache/concurrent/ConcurrencyUtilTest.java
===================================================================
--- src/test/java/net/sf/ehcache/concurrent/ConcurrencyUtilTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/concurrent/ConcurrencyUtilTest.java	(working copy)
@@ -17,13 +17,14 @@
 package net.sf.ehcache.concurrent;
 
 
-import net.sf.ehcache.CacheException;
 import static org.junit.Assert.assertTrue;
-import org.junit.Test;
 
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.CacheException;
+
+import org.junit.Test;
+
 
 /**
  * Isolation tests for ConcurrencyUtil
@@ -55,7 +56,7 @@
             if (20 <= lockIndexes[i] && lockIndexes[i] <= 40) {
                 continue;
             }
-            LOG.log(Level.INFO, i + ": " + lockIndexes[i]);
+            LOG.info(i + ": " + lockIndexes[i]);
             outliers++;
         }
         assertTrue(outliers <= 128);
Index: src/test/java/net/sf/ehcache/AbstractCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/AbstractCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/AbstractCacheTest.java	(working copy)
@@ -17,20 +17,22 @@
 package net.sf.ehcache;
 
 
-import org.junit.After;
-import org.junit.Assert;
 import static org.junit.Assert.assertTrue;
-import org.junit.Before;
 
-import javax.management.MBeanServer;
-import javax.management.MBeanServerFactory;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import javax.management.MBeanServer;
+import javax.management.MBeanServerFactory;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -56,7 +58,7 @@
     public static final String TEST_CLASSES_DIR = "target/test-classes/";
 
 
-    private static final Logger LOG = Logger.getLogger(AbstractCacheTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(AbstractCacheTest.class);
 
     /**
      * name for sample cache 1
@@ -148,7 +150,7 @@
      */
     protected void runThreads(final List executables) throws Exception {
         int failures = runThreadsNoCheck(executables);
-            LOG.log(Level.INFO, failures + " failures");
+            LOG.info("{} failures", failures);
             //CHM does have the occasional very slow time.
             assertTrue("Failures = " + failures, failures <= 35);
     }
@@ -181,9 +183,9 @@
                         // Hang on to any errors
                         errors.add(t);
                         if (t instanceof AssertionError) {
-                            LOG.log(Level.INFO, "Throwable " + t + " " + t.getMessage());
+                            LOG.info("Throwable " + t + " " + t.getMessage());
                         } else {
-                            LOG.log(Level.SEVERE, "Throwable " + t + " " + t.getMessage(), t);
+                            LOG.error("Throwable " + t + " " + t.getMessage(), t);
                         }
                     }
                 }
@@ -198,7 +200,7 @@
 
 //        if (errors.size() > 0) {
 //            for (Throwable error : errors) {
-//                LOG.log(Level.INFO, "Error", error);
+//                LOG.info("Error", error);
 //            }
 //        }
         return errors.size();
@@ -215,7 +217,7 @@
             Method method = managementFactoryClass.getMethod("getPlatformMBeanServer", (Class[]) null);
             return (MBeanServer) method.invoke(null, (Object[]) null);
         } catch (Exception e) {
-            LOG.log(Level.INFO, "JDK1.5 ManagementFactory not found. Falling back to JMX1.2.1", e);
+            LOG.info("JDK1.5 ManagementFactory not found. Falling back to JMX1.2.1", e);
             return MBeanServerFactory.createMBeanServer("SimpleAgent");
         }
     }
Index: src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerTest.java	(working copy)
@@ -17,16 +17,8 @@
 package net.sf.ehcache.distribution;
 
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.net.SocketTimeoutException;
 import java.rmi.RemoteException;
@@ -34,8 +26,18 @@
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Unit tests for RMICachePeer
@@ -47,7 +49,7 @@
  */
 public class RMICacheManagerPeerTest {
 
-    private static final Logger LOG = Logger.getLogger(RMICacheManagerPeerTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICacheManagerPeerTest.class);
 
 
     /**
@@ -207,7 +209,7 @@
             try {
                 Thread.sleep(2000);
             } catch (InterruptedException exception) {
-                LOG.log(Level.SEVERE, exception.getMessage(), exception);
+                LOG.error(exception.getMessage(), exception);
             }
         }
     }
Index: src/test/java/net/sf/ehcache/distribution/EventMessageTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/EventMessageTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/EventMessageTest.java	(working copy)
@@ -17,11 +17,8 @@
 package net.sf.ehcache.distribution;
 
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Element;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -31,9 +28,13 @@
 import java.lang.ref.SoftReference;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Element;
+
+import org.junit.Test;
+
 /**
  * Tests Serialization and SoftReferences in EventMessage
  *
@@ -61,7 +62,7 @@
             SoftReference softReference = (SoftReference) map.get(new Integer(i));
             byte[] payload = (byte[]) softReference.get();
             if (payload != null) {
-                LOG.log(Level.INFO, "Value found for " + i);
+                LOG.info("Value found for " + i);
                 counter++;
             }
         }
Index: src/test/java/net/sf/ehcache/distribution/ManualRMIPeerProviderTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/ManualRMIPeerProviderTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/ManualRMIPeerProviderTest.java	(working copy)
@@ -16,16 +16,18 @@
 
 package net.sf.ehcache.distribution;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+import java.util.List;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Ehcache;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
+
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.List;
-
 /**
  * @author <a href="mailto:gluck@thoughtworks.com">Greg Luck</a>
  * @version $Id$
Index: src/test/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/RMIBootstrapCacheLoaderTest.java	(working copy)
@@ -17,20 +17,22 @@
 package net.sf.ehcache.distribution;
 
 
+import static org.junit.Assert.assertEquals;
+
+import java.util.Date;
+import java.util.logging.Logger;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.event.CountingCacheEventListener;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Date;
-import java.util.logging.Logger;
-
 /**
  * @author Greg Luck
  * @version $Id$
Index: src/test/java/net/sf/ehcache/distribution/RMICacheReplicatorTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/RMICacheReplicatorTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/RMICacheReplicatorTest.java	(working copy)
@@ -16,24 +16,11 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.StopWatch;
-import net.sf.ehcache.ThreadKiller;
-import net.sf.ehcache.event.CountingCacheEventListener;
-import net.sf.ehcache.management.ManagementService;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -43,8 +30,23 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.StopWatch;
+import net.sf.ehcache.ThreadKiller;
+import net.sf.ehcache.event.CountingCacheEventListener;
+import net.sf.ehcache.management.ManagementService;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Tests replication of Cache events
@@ -71,7 +73,7 @@
      */
     protected static final boolean SYNCHRONOUS = false;
 
-    private static final Logger LOG = Logger.getLogger(RMICacheReplicatorTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(RMICacheReplicatorTest.class);
 
 
     /**
@@ -474,7 +476,7 @@
         }
         long elapsed = stopWatch.getElapsedTime();
         long putTime = ((elapsed / 1000));
-        LOG.log(Level.INFO, "Put Elapsed time: " + putTime);
+        LOG.info("Put Elapsed time: " + putTime);
         //assertTrue(putTime < 8);
 
         assertEquals(2000, cache1.getSize());
@@ -514,7 +516,7 @@
         }
         long elapsed = stopWatch.getElapsedTime();
         long putTime = ((elapsed / 1000));
-        LOG.log(Level.INFO, "Put Elapsed time: " + putTime);
+        LOG.info("Put Elapsed time: " + putTime);
 
         assertEquals(2000, cache1.getSize());
 
@@ -588,7 +590,7 @@
         }
         long elapsed = stopWatch.getElapsedTime();
         long putTime = ((elapsed / 1000));
-        LOG.log(Level.INFO, "Put Elapsed time: " + putTime);
+        LOG.info("Put Elapsed time: " + putTime);
         //assertTrue(putTime < 8);
 
         assertEquals(100000, cache1.getSize());
@@ -657,7 +659,7 @@
         assertEquals(0, manager4.getCache("sampleCache1").getSize());
         assertEquals(0, manager5.getCache("sampleCache1").getSize());
 
-        LOG.log(Level.INFO, "Remove Elapsed time: " + timeForPropagate);
+        LOG.info("Remove Elapsed time: " + timeForPropagate);
 
 
     }
@@ -691,7 +693,7 @@
         }
         long elapsed = stopWatch.getElapsedTime();
         long putTime = ((elapsed / 1000));
-        LOG.log(Level.INFO, "Put and Propagate Synchronously Elapsed time: " + putTime + " seconds");
+        LOG.info("Put and Propagate Synchronously Elapsed time: " + putTime + " seconds");
 
         assertEquals(2000, manager1.getCache("sampleCache3").getSize());
         assertEquals(2000, manager2.getCache("sampleCache3").getSize());
@@ -1363,7 +1365,7 @@
             final long end = System.currentTimeMillis();
             if (end - start >= 1000) {
                 start = end;
-                LOG.log(Level.INFO, "Items written: " + count);
+                LOG.info("Items written: " + count);
                 //make sure it does not choke
                 assertTrue(count > 1000);
                 count = 0;
@@ -1481,14 +1483,10 @@
                 Cache cache = manager.getCache(cacheName);
                 if (operationSelector == 100) {
                     cache.get(key);
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, cache.getGuid() + ": get " + key);
-                    }
+                    LOG.debug("{}: get {}", cache.getGuid(), key);
                 } else if (operationSelector == 100) {
                     cache.remove(key);
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, cache.getGuid() + ": remove " + key);
-                    }
+                    LOG.debug("{}: remove {}", cache.getGuid(), key);
                 } else if (operationSelector == 2) {
                     cache.put(new Element(key,
                             "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
@@ -1496,13 +1494,11 @@
                                     + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                                     + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                                     + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"));
-                    if (LOG.isLoggable(Level.FINE)) {
-                        LOG.log(Level.FINE, cache.getGuid() + ": put " + key);
-                    }
+                    LOG.debug("{}: put {}", cache.getGuid(), key);
                 } else {
                     //every twelfth time 1/4 * 1/3 = 1/12
                     if (random.nextInt(3) == 1) {
-                        LOG.log(Level.FINE, "cache.removeAll()");
+                        LOG.debug("cache.removeAll()");
                         cache.removeAll();
                     }
                 }
Index: src/test/java/net/sf/ehcache/distribution/PayloadUtilTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/PayloadUtilTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/PayloadUtilTest.java	(working copy)
@@ -17,19 +17,20 @@
 package net.sf.ehcache.distribution;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.util.logging.Logger;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.StopWatch;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Note these tests need a live network interface running in multicast mode to work
  *
@@ -74,7 +75,7 @@
         final byte[] compressed = PayloadUtil.gzip(payload.getBytes());
 
         int length = compressed.length;
-        LOG.log(Level.INFO, "gzipped size: " + length);
+        LOG.info("gzipped size: " + length);
         assertTrue("Heartbeat too big for one Datagram " + length, length <= 1500);
 
     }
@@ -104,7 +105,7 @@
             }
         }
         long elapsed = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Gzip took " + elapsed / 10F + " s");
+        LOG.info("Gzip took " + elapsed / 10F + " s");
     }
 
     /**
@@ -133,7 +134,7 @@
             PayloadUtil.ungzip(compressed);
         }
         long elapsed = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Ungzip took " + elapsed / 10000F + " s");
+        LOG.info("Ungzip took " + elapsed / 10000F + " s");
     }
 
 
Index: src/test/java/net/sf/ehcache/distribution/MulticastRMIPeerProviderTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/MulticastRMIPeerProviderTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/MulticastRMIPeerProviderTest.java	(working copy)
@@ -16,25 +16,26 @@
 
 package net.sf.ehcache.distribution;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.StopWatch;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.MulticastSocket;
 import java.rmi.RemoteException;
 import java.util.List;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.StopWatch;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 /**
  * Multicast tests. These require special machine configuration.
  * <p/>
@@ -235,7 +236,7 @@
         }
         long time = stopWatch.getElapsedTime();
 
-        LOG.log(Level.INFO, "Remote name lookup time in ms: " + time / 1000f);
+        LOG.info("Remote name lookup time in ms: " + time / 1000f);
 
     }
 
Index: src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/RMICacheManagerPeerListenerTest.java	(working copy)
@@ -17,6 +17,13 @@
 package net.sf.ehcache.distribution;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.rmi.Remote;
+import java.rmi.RemoteException;
+import java.util.List;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
@@ -24,16 +31,11 @@
 import net.sf.ehcache.Status;
 import net.sf.ehcache.event.CacheEventListener;
 import net.sf.ehcache.event.CountingCacheEventListener;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.rmi.Remote;
-import java.rmi.RemoteException;
-import java.util.List;
-
 /**
  * Unit tests for the RMICacheManagerPeerListener
  * <p/>
Index: src/test/java/net/sf/ehcache/distribution/RMIDistributedCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/distribution/RMIDistributedCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/distribution/RMIDistributedCacheTest.java	(working copy)
@@ -17,19 +17,21 @@
 package net.sf.ehcache.distribution;
 
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.rmi.Naming;
+import java.util.Date;
+
 import net.sf.ehcache.AbstractCacheTest;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.rmi.Naming;
-import java.util.Date;
-
 /**
  * Note these tests need a live network interface running in multicast mode to work
  *
Index: src/test/java/net/sf/ehcache/ElementTest.java
===================================================================
--- src/test/java/net/sf/ehcache/ElementTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/ElementTest.java	(working copy)
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -31,8 +30,10 @@
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.HashMap;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Test cases for the Element.
@@ -42,7 +43,7 @@
  */
 public class ElementTest extends AbstractCacheTest {
 
-    private static final Logger LOG = Logger.getLogger(ElementTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(ElementTest.class);
 
 
     /**
@@ -62,7 +63,7 @@
             try {
                 bout.write("abcdefghijklmnopqrstv1234567890".getBytes());
             } catch (IOException e) {
-                LOG.log(Level.SEVERE, "This should not happen");
+                LOG.error("This should not happen");
             }
         }
         byte[] value = bout.toByteArray();
@@ -73,7 +74,7 @@
             element.getSerializedSize();
         }
         long elapsed = stopWatch.getElapsedTime() / 100;
-        LOG.log(Level.INFO, "In-memory size in bytes: " + element.getSerializedSize()
+        LOG.info("In-memory size in bytes: " + element.getSerializedSize()
                 + " time to serialize in ms: " + elapsed);
         assertTrue("Large object clone takes more than than 100ms", elapsed < 100);
     }
@@ -96,7 +97,7 @@
             element.getSerializedSize();
         }
         long elapsed = stopWatch.getElapsedTime() / 100;
-        LOG.log(Level.INFO, "In-memory size in bytes: " + element.getSerializedSize()
+        LOG.info("In-memory size in bytes: " + element.getSerializedSize()
                 + " time to serialize in ms: " + elapsed);
         assertTrue("Large object clone took more than 500ms", elapsed < 500);
     }
@@ -119,8 +120,8 @@
             element.clone();
         }
         long elapsed = stopWatch.getElapsedTime() / 100;
-        LOG.log(Level.INFO, "Time to clone object in ms: " + elapsed);
-        LOG.log(Level.INFO, "In-memory size in bytes: " + element.getSerializedSize()
+        LOG.info("Time to clone object in ms: " + elapsed);
+        LOG.info("In-memory size in bytes: " + element.getSerializedSize()
                 + " time to clone in ms: " + elapsed);
         assertTrue("Large object clone takes less than 1 second", elapsed < 1000);
     }
@@ -147,7 +148,7 @@
             element.clone();
         }
         long elapsed = stopWatch.getElapsedTime() / 100;
-        LOG.log(Level.INFO, "In-memory size in bytes: " + element.getSerializedSize()
+        LOG.info("In-memory size in bytes: " + element.getSerializedSize()
                 + " time to serialize in ms: " + elapsed);
         assertTrue("Large object clone takes less than 130 milliseconds", elapsed < 180);
     }
@@ -159,7 +160,7 @@
             try {
                 bout.write("abcdefghijklmnopqrstv1234567890".getBytes());
             } catch (IOException e) {
-                LOG.log(Level.SEVERE, "This should not happen");
+                LOG.error("This should not happen");
             }
         }
         return bout.toByteArray();
@@ -191,7 +192,7 @@
             ois.close();
         }
         long elapsed = stopWatch.getElapsedTime() / 100;
-        LOG.log(Level.INFO, "In-memory size in bytes: " + serializedValue.length
+        LOG.info("In-memory size in bytes: " + serializedValue.length
                 + " time to deserialize in ms: " + elapsed);
         assertTrue(elapsed < 30);
     }
Index: src/test/java/net/sf/ehcache/CacheManagerTest.java
===================================================================
--- src/test/java/net/sf/ehcache/CacheManagerTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/CacheManagerTest.java	(working copy)
@@ -16,6 +16,23 @@
 
 package net.sf.ehcache;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.logging.Logger;
+
 import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
 import net.sf.ehcache.config.CacheConfiguration;
 import net.sf.ehcache.config.Configuration;
@@ -31,26 +48,10 @@
 import net.sf.ehcache.event.RegisteredEventListeners;
 import net.sf.ehcache.store.DiskStore;
 import net.sf.ehcache.store.Store;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 import org.junit.Test;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Tests for CacheManager
  *
@@ -623,7 +624,7 @@
             }
         }
         long elapsedTime = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time taken was: " + elapsedTime);
+        LOG.info("Time taken was: " + elapsedTime);
         assertTrue("Time taken was: " + elapsedTime, elapsedTime < 5000);
     }
 
@@ -754,7 +755,7 @@
         for (int i = 0; i < threads.size(); i++) {
             Thread thread = (Thread) threads.get(i);
             String name = thread.getName();
-            LOG.log(Level.INFO, name);
+            LOG.info(name);
         }
     }
 
Index: src/test/java/net/sf/ehcache/constructs/blocking/CountingCacheEntryFactory.java
===================================================================
--- src/test/java/net/sf/ehcache/constructs/blocking/CountingCacheEntryFactory.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/constructs/blocking/CountingCacheEntryFactory.java	(working copy)
@@ -16,10 +16,10 @@
 
 package net.sf.ehcache.constructs.blocking;
 
-import net.sf.ehcache.Element;
-
 import java.util.Random;
 
+import net.sf.ehcache.Element;
+
 /**
  * A cache entry factory that counts the number of entries it has created.
  * <p/>
Index: src/test/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/constructs/blocking/UpdatingSelfPopulatingCacheTest.java	(working copy)
@@ -17,21 +17,23 @@
 package net.sf.ehcache.constructs.blocking;
 
 import static junit.framework.Assert.assertSame;
-import net.sf.ehcache.CacheException;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.StopWatch;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.CacheException;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.StopWatch;
 
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * Test cases for the {@link UpdatingSelfPopulatingCache}.
@@ -41,7 +43,7 @@
  */
 public class UpdatingSelfPopulatingCacheTest extends SelfPopulatingCacheTest {
 
-    private static final Logger LOG = Logger.getLogger(UpdatingSelfPopulatingCacheTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(UpdatingSelfPopulatingCacheTest.class);
 
     /**
      * Tests fetching an entry, and then an update.
@@ -135,7 +137,7 @@
         final CountingCacheEntryFactory factory = new CountingCacheEntryFactory(value);
         selfPopulatingCache = new UpdatingSelfPopulatingCache(cache, factory);
         long duration = thrashCache((UpdatingSelfPopulatingCache) selfPopulatingCache, 300L, 1500L);
-        LOG.log(Level.FINE, "Thrash Duration:" + duration);
+        LOG.debug("Thrash Duration:" + duration);
     }
 
     /**
Index: src/test/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/constructs/blocking/SelfPopulatingCacheTest.java	(working copy)
@@ -17,24 +17,25 @@
 package net.sf.ehcache.constructs.blocking;
 
 import static junit.framework.Assert.assertSame;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.CacheTest;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.event.CountingCacheEventListener;
+
 import org.junit.After;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 import org.junit.Before;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 
 /**
@@ -46,7 +47,7 @@
  */
 public class SelfPopulatingCacheTest extends CacheTest {
 
-    private static final Logger LOG = Logger.getLogger(SelfPopulatingCacheTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(SelfPopulatingCacheTest.class);
 
     /**
      * Shared with subclass
@@ -95,7 +96,7 @@
      */
     @Test
     public void testFetch() throws Exception {
-        LOG.log(Level.SEVERE, ".");
+        LOG.error(".");
 
         // Lookup
         final Element element = selfPopulatingCache.get("key");
@@ -404,7 +405,7 @@
             try {
                 cache.get(key);
             } catch (Exception e) {
-                LOG.log(Level.INFO, "Exception: " + e.getMessage());
+                LOG.info("Exception: " + e.getMessage());
             }
         }
     }
@@ -456,7 +457,7 @@
             }
         } catch (OutOfMemoryError e) {
             //the disk store backs up on the laptop. 
-            LOG.log(Level.INFO, "OutOfMemoryError: " + e.getMessage() + " " + i);
+            LOG.info("OutOfMemoryError: " + e.getMessage() + " " + i);
             fail();
         }
     }
Index: src/test/java/net/sf/ehcache/constructs/blocking/BlockingCacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/constructs/blocking/BlockingCacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/constructs/blocking/BlockingCacheTest.java	(working copy)
@@ -16,27 +16,29 @@
 
 package net.sf.ehcache.constructs.blocking;
 
-import net.sf.ehcache.Cache;
-import net.sf.ehcache.CacheTest;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.Status;
-import net.sf.ehcache.StopWatch;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheTest;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.Status;
+import net.sf.ehcache.StopWatch;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Test cases for the {@link BlockingCache}.
@@ -47,7 +49,7 @@
  */
 public class BlockingCacheTest extends CacheTest {
 
-    private static final Logger LOG = Logger.getLogger(BlockingCacheTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(BlockingCacheTest.class);
     private BlockingCache blockingCache;
 
     /**
@@ -228,7 +230,7 @@
         Ehcache cache = manager.getCache("sampleCache1");
         blockingCache = new BlockingCache(cache);
         long duration = thrashCache(blockingCache, 50, 500L, 1000L);
-        LOG.log(Level.FINE, "Thrash Duration:" + duration);
+        LOG.debug("Thrash Duration:" + duration);
     }
 
     /**
@@ -248,7 +250,7 @@
         } catch (Exception e) {
             //expected
         }
-        LOG.log(Level.FINE, "Thrash Duration:" + duration);
+        LOG.debug("Thrash Duration:" + duration);
     }
 
     /**
@@ -261,7 +263,7 @@
         blockingCache = new BlockingCache(cache);
         blockingCache.setTimeoutMillis((int) (400 * StopWatch.getSpeedAdjustmentFactor()));
         long duration = thrashCache(blockingCache, 50, 400L, (long) (1000L * StopWatch.getSpeedAdjustmentFactor()));
-        LOG.log(Level.FINE, "Thrash Duration:" + duration);
+        LOG.debug("Thrash Duration:" + duration);
     }
 
     /**
Index: src/test/java/net/sf/ehcache/CacheTest.java
===================================================================
--- src/test/java/net/sf/ehcache/CacheTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/CacheTest.java	(working copy)
@@ -17,22 +17,12 @@
 package net.sf.ehcache;
 
 import static junit.framework.Assert.assertSame;
-import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
-import net.sf.ehcache.event.CacheEventListener;
-import net.sf.ehcache.event.RegisteredEventListeners;
-import net.sf.ehcache.exceptionhandler.ExceptionHandlingDynamicCacheProxy;
-import net.sf.ehcache.loader.CacheLoader;
-import net.sf.ehcache.loader.CountingCacheLoader;
-import net.sf.ehcache.loader.ExceptionThrowingLoader;
-import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.Serializable;
@@ -44,15 +34,27 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.Vector;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
 import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.concurrent.atomic.AtomicLong;
 
+import net.sf.ehcache.bootstrap.BootstrapCacheLoader;
+import net.sf.ehcache.event.CacheEventListener;
+import net.sf.ehcache.event.RegisteredEventListeners;
+import net.sf.ehcache.exceptionhandler.ExceptionHandlingDynamicCacheProxy;
+import net.sf.ehcache.loader.CacheLoader;
+import net.sf.ehcache.loader.CountingCacheLoader;
+import net.sf.ehcache.loader.ExceptionThrowingLoader;
+import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
+
+import org.junit.After;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 
 /**
  * Tests for a Cache
@@ -62,7 +64,7 @@
  */
 public class CacheTest extends AbstractCacheTest {
 
-    private static final Logger LOG = Logger.getLogger(CacheTest.class.getName());
+    private static final Logger LOG = LoggerFactory.getLogger(CacheTest.class);
 
 
     /**
@@ -275,22 +277,22 @@
         cache.put(new Element("key1", "value1"));
         Element element = cache.get("key1");
         assertTrue(element.getCreationTime() >= beforeElementCreation);
-        LOG.log(Level.INFO, "version: " + element.getVersion());
-        LOG.log(Level.INFO, "creationTime: " + element.getCreationTime());
-        LOG.log(Level.INFO, "lastUpdateTime: " + element.getLastUpdateTime());
+        LOG.info("version: " + element.getVersion());
+        LOG.info("creationTime: " + element.getCreationTime());
+        LOG.info("lastUpdateTime: " + element.getLastUpdateTime());
         assertEquals(0, element.getLastUpdateTime());
 
         cache.put(new Element("key1", "value1"));
         element = cache.get("key1");
-        LOG.log(Level.INFO, "version: " + element.getVersion());
-        LOG.log(Level.INFO, "creationTime: " + element.getCreationTime());
-        LOG.log(Level.INFO, "lastUpdateTime: " + element.getLastUpdateTime());
+        LOG.info("version: " + element.getVersion());
+        LOG.info("creationTime: " + element.getCreationTime());
+        LOG.info("lastUpdateTime: " + element.getLastUpdateTime());
 
         cache.put(new Element("key1", "value1"));
         element = cache.get("key1");
-        LOG.log(Level.INFO, "version: " + element.getVersion());
-        LOG.log(Level.INFO, "creationTime: " + element.getCreationTime());
-        LOG.log(Level.INFO, "lastUpdateTime: " + element.getLastUpdateTime());
+        LOG.info("version: " + element.getVersion());
+        LOG.info("creationTime: " + element.getCreationTime());
+        LOG.info("lastUpdateTime: " + element.getLastUpdateTime());
     }
 
 
@@ -490,7 +492,7 @@
             memoryOnlyCache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for MemoryStore: " + time);
+        LOG.info("Time for MemoryStore: " + time);
         assertTrue("Time to put and get 5000 entries into MemoryStore", time < 300);
 
         //Memory only Typical 192ms
@@ -502,7 +504,7 @@
                 memoryOnlyCache.get(key);
             }
             time = stopWatch.getElapsedTime();
-            LOG.log(Level.INFO, "Time for MemoryStore: " + time);
+            LOG.info("Time for MemoryStore: " + time);
             assertTrue("Time to put and get 5000 entries into MemoryStore", time < 300);
             Thread.sleep(500);
         }
@@ -518,7 +520,7 @@
                 exceptionHandlingMemoryOnlyCache.get(key);
             }
             time = stopWatch.getElapsedTime();
-            LOG.log(Level.INFO, "Time for exception handling MemoryStore: " + time);
+            LOG.info("Time for exception handling MemoryStore: " + time);
             assertTrue("Time to put and get 5000 entries into exception handling MemoryStore", time < 300);
             Thread.sleep(500);
         }
@@ -535,7 +537,7 @@
             diskOnlyCache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for DiskStore: " + time);
+        LOG.info("Time for DiskStore: " + time);
         assertTrue("Time to put and get 5000 entries into DiskStore was less than 2 sec", time < 2000);
 
         // 1 Memory, 999 Disk
@@ -550,7 +552,7 @@
             m1d999Cache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for m1d999Cache: " + time);
+        LOG.info("Time for m1d999Cache: " + time);
         assertTrue("Time to put and get 5000 entries into m1d999Cache", time < 2000);
 
         // 500 Memory, 500 Disk
@@ -565,7 +567,7 @@
             m500d500Cache.get(key);
         }
         time = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time for m500d500Cache: " + time);
+        LOG.info("Time for m500d500Cache: " + time);
         assertTrue("Time to put and get 5000 entries into m500d500Cache", time < 2000);
 
     }
@@ -650,7 +652,7 @@
         CacheManager manager = CacheManager.getInstance();
         cache = manager.getCache(name);
         if (cache == null) {
-            LOG.log(Level.WARNING, "Could not find configuration for " + name
+            LOG.warn("Could not find configuration for " + name
                     + ". Configuring using the defaultCache settings.");
             manager.addCache(name);
             cache = manager.getCache(name);
@@ -1016,7 +1018,7 @@
         long getKeysTime = stopWatch.getElapsedTime();
         cache.getKeysNoDuplicateCheck();
         long getKeysNoDuplicateCheckTime = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "Time to get 1000 keys: With Duplicate Check: " + getKeysTime
+        LOG.info("Time to get 1000 keys: With Duplicate Check: " + getKeysTime
                 + " Without Duplicate Check: " + getKeysNoDuplicateCheckTime);
         assertTrue("Getting keys took more than 150ms", getKeysTime < 100);
     }
@@ -1043,7 +1045,7 @@
         long size = cache.calculateInMemorySize();
         assertTrue("Size is " + size + ". Check it for reasonableness.", size > 100000 && size < 5000000);
         long elapsed = stopWatch.getElapsedTime();
-        LOG.log(Level.INFO, "In-memory size in bytes: " + size
+        LOG.info("In-memory size in bytes: " + size
                 + " time to calculate in ms: " + elapsed);
         assertTrue("Calculate memory size takes less than 3.5 seconds", elapsed < 3500);
     }
@@ -1250,7 +1252,7 @@
         //this one does
         cache.put(new Element("nullValue", null));
 
-        LOG.log(Level.INFO, "Size: " + cache.getDiskStoreSize());
+        LOG.info("Size: " + cache.getDiskStoreSize());
 
         assertEquals(50, cache.getMemoryStoreSize());
         assertEquals(54, cache.getDiskStoreSize());
@@ -1333,7 +1335,7 @@
         for (int i = 0; i < 80000; i++) {
             cache.put(new Element("" + i, new byte[480]));
         }
-        LOG.log(Level.INFO, "Put time: " + stopWatch.getElapsedTime());
+        LOG.info("Put time: " + stopWatch.getElapsedTime());
         Thread.sleep(2000);
         assertEquals(40000, cache.getMemoryStoreSize());
         assertEquals(40000, cache.getDiskStoreSize());
@@ -1341,7 +1343,7 @@
         long beforeMemory = measureMemoryUse();
         stopWatch.getElapsedTime();
         cache.flush();
-        LOG.log(Level.INFO, "Flush time: " + stopWatch.getElapsedTime());
+        LOG.info("Flush time: " + stopWatch.getElapsedTime());
 
         //It takes a while to write all the Elements to disk
         Thread.sleep(1000);
@@ -1376,7 +1378,7 @@
                 cache.put(a);
             }
         } catch (OutOfMemoryError e) {
-            LOG.log(Level.INFO, "OutOfMemoryError: " + e.getMessage() + " " + i);
+            LOG.info("OutOfMemoryError: " + e.getMessage() + " " + i);
             fail();
         }
     }
@@ -2081,22 +2083,22 @@
 
         try {
             int failures = runThreadsNoCheck(executables);
-            LOG.log(Level.INFO, failures + " failures");
+            LOG.info(failures + " failures");
             //CHM does have the occasional very slow time.
             assertTrue("Failures = " + failures, failures <= 50);
         } finally {
-            LOG.log(Level.INFO, "Average Get Time for " + getTimeCount.get() + " observations: "
+            LOG.info("Average Get Time for " + getTimeCount.get() + " observations: "
                     + getTimeSum.floatValue() / getTimeCount.get() + " ms");
-            LOG.log(Level.INFO, "Average Put Time for " + putTimeCount.get() + " obervations: "
+            LOG.info("Average Put Time for " + putTimeCount.get() + " obervations: "
                     + putTimeSum.floatValue() / putTimeCount.get() + " ms");
-            LOG.log(Level.INFO, "Average Remove Time for " + removeTimeCount.get() + " obervations: "
+            LOG.info("Average Remove Time for " + removeTimeCount.get() + " obervations: "
                     + removeTimeSum.floatValue() / removeTimeCount.get() + " ms");
-            LOG.log(Level.INFO, "Average Remove All Time for " + removeAllTimeCount.get() + " observations: "
+            LOG.info("Average Remove All Time for " + removeAllTimeCount.get() + " observations: "
                     + removeAllTimeSum.floatValue() / removeAllTimeCount.get() + " ms");
-            LOG.log(Level.INFO, "Average keySet Time for " + keySetTimeCount.get() + " observations: "
+            LOG.info("Average keySet Time for " + keySetTimeCount.get() + " observations: "
                     + keySetTimeSum.floatValue() / keySetTimeCount.get() + " ms");
-            LOG.log(Level.INFO, "Total loads: " + countingCacheLoader.getLoadCounter());
-            LOG.log(Level.INFO, "Total loadAlls: " + countingCacheLoader.getLoadAllCounter());
+            LOG.info("Total loads: " + countingCacheLoader.getLoadCounter());
+            LOG.info("Total loadAlls: " + countingCacheLoader.getLoadAllCounter());
         }
     }
 
@@ -2210,13 +2212,13 @@
 
 
             int failures = runThreadsNoCheck(executables);
-            LOG.log(Level.INFO, failures + " failures");
+            LOG.info(failures + " failures");
             assertTrue(failures == 0);
             long totalReadTime = 0;
             for (Long readTime : readTimes) {
                 totalReadTime += readTime;
             }
-            LOG.log(Level.INFO, threads + " threads. Average Get time: " + totalReadTime / (float) readTimes.size() + " ms");
+            LOG.info(threads + " threads. Average Get time: " + totalReadTime / (float) readTimes.size() + " ms");
 
         }
 
@@ -2330,7 +2332,7 @@
          */
         protected void finalize() throws Throwable {
             manager.getCache("test").getQuiet("key");
-            LOG.log(Level.INFO, "finalize run from thread " + Thread.currentThread().getName());
+            LOG.info("finalize run from thread " + Thread.currentThread().getName());
             super.finalize();
         }
     }
@@ -2346,7 +2348,7 @@
 
 
             public Object load(Object key, Object argument) throws CacheException {
-                LOG.log(Level.INFO, "load1 " + key);
+                LOG.info("load1 " + key);
                 return key;
             }
 
@@ -2376,7 +2378,7 @@
             }
 
             public Object load(Object o) throws CacheException {
-                LOG.log(Level.INFO, "load2 " + o + " " + o.getClass());
+                LOG.info("load2 " + o + " " + o.getClass());
                 if (o.equals("c")) {
                     return null;
                 }
Index: src/test/java/net/sf/ehcache/CacheExceptionTest.java
===================================================================
--- src/test/java/net/sf/ehcache/CacheExceptionTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/CacheExceptionTest.java	(working copy)
@@ -18,6 +18,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+
 import org.junit.Test;
 
 
Index: src/test/java/net/sf/ehcache/management/ManagementServiceTest.java
===================================================================
--- src/test/java/net/sf/ehcache/management/ManagementServiceTest.java	(revision 1022)
+++ src/test/java/net/sf/ehcache/management/ManagementServiceTest.java	(working copy)
@@ -16,17 +16,17 @@
 
 package net.sf.ehcache.management;
 
-import net.sf.ehcache.AbstractCacheTest;
-import net.sf.ehcache.Ehcache;
-import net.sf.ehcache.Element;
-import net.sf.ehcache.config.Configuration;
-import net.sf.ehcache.config.ConfigurationFactory;
-import org.junit.After;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import org.junit.Before;
-import org.junit.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.rmi.registry.LocateRegistry;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.logging.Logger;
 
 import javax.management.JMException;
 import javax.management.MBeanAttributeInfo;
@@ -39,14 +39,16 @@
 import javax.management.remote.JMXConnectorServer;
 import javax.management.remote.JMXConnectorServerFactory;
 import javax.management.remote.JMXServiceURL;
-import java.io.File;
-import java.io.IOException;
-import java.rmi.registry.LocateRegistry;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+
+import net.sf.ehcache.AbstractCacheTest;
+import net.sf.ehcache.Ehcache;
+import net.sf.ehcache.Element;
+import net.sf.ehcache.config.Configuration;
+import net.sf.ehcache.config.ConfigurationFactory;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 /**
  * These tests use the JDK1.5 platform mbean server
@@ -265,7 +267,7 @@
         ObjectName name = CacheManager.createObjectName(manager);
 
         Object object = mBeanServer.getAttribute(name, "Status");
-        LOG.log(Level.INFO, object.toString());
+        LOG.info(object.toString());
 
         List caches = (List) mBeanServer.getAttribute(name, "Caches");
         assertEquals(13, caches.size());
@@ -275,7 +277,7 @@
             String cacheName = cache.getName();
             CacheStatistics cacheStatistics = cache.getStatistics();
             CacheConfiguration cacheConfiguration = cache.getCacheConfiguration();
-            LOG.log(Level.INFO, cacheName + " " + cacheStatistics + " " + cacheConfiguration);
+            LOG.info(cacheName + " " + cacheStatistics + " " + cacheConfiguration);
         }
     }
 
@@ -358,7 +360,7 @@
             MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();
             for (int i = 0; i < attributes.length; i++) {
                 MBeanAttributeInfo attribute = attributes[i];
-                LOG.log(Level.INFO, attribute.getName() + " " + connection.getAttribute(objectName, attribute.getName()));
+                LOG.info(attribute.getName() + " " + connection.getAttribute(objectName, attribute.getName()));
             }
         }
     }
@@ -371,7 +373,7 @@
             MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();
             for (int i = 0; i < attributes.length; i++) {
                 MBeanAttributeInfo attribute = attributes[i];
-                LOG.log(Level.INFO, attribute.getName() + " " + mBeanServer.getAttribute(objectName, attribute.getName()));
+                LOG.info(attribute.getName() + " " + mBeanServer.getAttribute(objectName, attribute.getName()));
             }
         }
     }
Index: pom.xml
===================================================================
--- pom.xml	(revision 1022)
+++ pom.xml	(working copy)
@@ -10,7 +10,7 @@
     <name>Ehcache Core</name>
     <artifactId>ehcache</artifactId>
     <packaging>jar</packaging>
-    <version>1.6.2</version>
+    <version>1.6.2-slf4j</version>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -31,11 +31,22 @@
             <artifactId>hibernate</artifactId>
             <scope>provided</scope>
             <version>3.2.6.ga</version>
-
+        </dependency>
+        <dependency>
+        	<groupId>org.slf4j</groupId>
+        	<artifactId>slf4j-api</artifactId>
+        	<version>1.5.8</version>
+        	<scope>compile</scope>
         </dependency>
 
         <!--  Test scope -->
         <dependency>
+        	<groupId>org.slf4j</groupId>
+        	<artifactId>slf4j-log4j12</artifactId>
+        	<version>1.5.8</version>
+        	<scope>test</scope>
+        </dependency>
+        <dependency>
             <groupId>net.sf.hibernate</groupId>
             <artifactId>hibernate</artifactId>
             <scope>test</scope>
